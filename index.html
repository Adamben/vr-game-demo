<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Hand-only VR â€” Hand Tracking Fix (requests hand-tracking + joint visuals)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { margin:0; overflow:hidden; font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif; }
    #info {
      position: absolute; left: 10px; top: 10px; padding:10px 14px; background: rgba(0,0,0,0.45);
      color: #fff; border-radius:8px; max-width:380px; line-height:1.2;
    }
    #xrBtn { display:block; margin-top:8px; }
  </style>
</head>
<body>
  <div id="info">
    Hand-tracking: requested by default. Click <button id="xrBtn">Enter VR (request hands)</button><br>
    If your headset/browser supports hand-tracking the hand joints will appear and you can pinch/rub to play.
  </div>

  <script type="module">
  import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js';
  import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

  // ---- Basic renderer/scene/camera ----
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x081018);
  const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.05, 1000);
  const renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setSize(innerWidth, innerHeight);
  renderer.xr.enabled = true;
  renderer.shadowMap.enabled = true;
  document.body.appendChild(renderer.domElement);

  // simple lighting
  const hemi = new THREE.HemisphereLight(0xffffff, 0x222244, 0.9); hemi.position.set(0,10,0); scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 0.6); dir.position.set(2,6,4); dir.castShadow=true; scene.add(dir);

  // rig
  const rig = new THREE.Group();
  rig.add(camera);
  scene.add(rig);

  // ---- Cannon world ----
  const world = new CANNON.World({ gravity: new CANNON.Vec3(0,-9.82,0) });
  world.broadphase = new CANNON.SAPBroadphase(world);
  world.solver.iterations = 10;
  const defaultMat = new CANNON.Material('default');
  world.addContactMaterial(new CANNON.ContactMaterial(defaultMat, defaultMat, { friction:0.5, restitution:0.05 }));

  // ground
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(120,120), new THREE.MeshStandardMaterial({ color:0x263238 }));
  ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);
  const groundBody = new CANNON.Body({ type: CANNON.Body.STATIC, shape: new CANNON.Plane(), material: defaultMat });
  groundBody.quaternion.setFromEuler(-Math.PI/2,0,0); world.addBody(groundBody);

  // small scene objects
  const interactMeshes = [], interactBodies = [];
  function spawnBox(x,y,z,color=0x4488ff,mass=2){
    const m = new THREE.Mesh(new THREE.BoxGeometry(0.6,0.6,0.6), new THREE.MeshStandardMaterial({ color }));
    m.castShadow=true; m.position.set(x,y,z); scene.add(m);
    const b = new CANNON.Body({ mass, shape: new CANNON.Box(new CANNON.Vec3(0.3,0.3,0.3)), position: new CANNON.Vec3(x,y,z), material: defaultMat });
    world.addBody(b);
    interactMeshes.push(m); interactBodies.push(b);
    return { m,b };
  }

  spawnBox(-3,0.375,-1.5,0x4455aa,0); // static block
  spawnBox(3,0.6,-2,0xaa5544,0); // static block

  spawnBox(1.5,1,-1,0x4488ff,2);
  spawnBox(-1.5,1,-1,0xffaa33,2);
  spawnBox(0,2,-2,0x00ffaa,2);

  // orbit sphere + central static cube
  const centralMesh = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshStandardMaterial({ color:0xff4444 }));
  centralMesh.position.set(0,0.5,0); centralMesh.castShadow = true; scene.add(centralMesh);
  const centralBody = new CANNON.Body({ type: CANNON.Body.STATIC, shape: new CANNON.Box(new CANNON.Vec3(0.5,0.5,0.5)), position: new CANNON.Vec3(0,0.5,0), material: defaultMat });
  world.addBody(centralBody);

  const sphereMesh = new THREE.Mesh(new THREE.SphereGeometry(0.4,32,32), new THREE.MeshStandardMaterial({ color:0x00ff88 }));
  sphereMesh.castShadow = true; scene.add(sphereMesh);
  const sphereBody = new CANNON.Body({ mass:1, shape: new CANNON.Sphere(0.4), position: new CANNON.Vec3(2,1,0), material: defaultMat });
  world.addBody(sphereBody);

  // player physics body (for pushing)
  const playerBody = new CANNON.Body({ mass:1, shape: new CANNON.Sphere(0.35), position: new CANNON.Vec3(0,1,4), fixedRotation:true, material: defaultMat });
  playerBody.linearDamping = 0.9; world.addBody(playerBody);

  // ---- Hand-tracking (request on XR session) ----
  // We'll create hand groups using renderer.xr.getHand(N) and attach small joint meshes to hand.joints[] after the session starts.
  const xrHands = [ renderer.xr.getHand(0), renderer.xr.getHand(1) ];
  xrHands.forEach(h => scene.add(h)); // add to scene now (they'll be populated after session)

  // joint mesh containers so we can create/attach meshes to real XR joint nodes later
  const jointMeshes = [ {}, {} ]; // jointMeshes[handIndex][jointName] = mesh
  const jointNames = [
    'wrist',
    'thumb-metacarpal','thumb-phalanx-proximal','thumb-phalanx-distal','thumb-tip',
    'index-finger-metacarpal','index-finger-proximal','index-finger-intermediate','index-finger-distal','index-finger-tip',
    'middle-finger-tip','ring-finger-tip','pinky-finger-tip'
  ];

  // helper to create a small sphere
  function makeJointMesh(r=0.02, color=0xffcc88){
    const g = new THREE.Mesh(new THREE.SphereGeometry(r,8,8), new THREE.MeshStandardMaterial({ color }));
    g.castShadow = true;
    return g;
  }

  // Called once after we start XR to create visual spheres and parent them to hand.joints nodes when available
  function createJointVisualsForSession(session) {
    // each hand
    for (let i=0;i<2;i++){
      const hand = xrHands[i];
      jointNames.forEach(name => {
        // if scene already has a mesh for this joint, skip
        if (jointMeshes[i][name]) return;
        // create mesh and try to attach to the XR joint when available
        const mesh = makeJointMesh(0.03, i===0 ? 0xff9966 : 0x66ccff);
        jointMeshes[i][name] = mesh;
        // Try to attach to the joint node if it exists; otherwise we will check every frame (safe)
        try {
          if (hand.joints && hand.joints[name]) {
            hand.joints[name].add(mesh);
            mesh.visible = true;
          } else {
            // fallback: add to hand group and we'll update position manually each frame
            hand.add(mesh);
            mesh.visible = true;
          }
        } catch(e) {
          // worst-case: add to scene and hide until we can parent it
          scene.add(mesh);
          mesh.visible = true;
        }
      });
    }
    console.log('Joint visuals created and (where possible) parented to XR hand joints.');
  }

  // helper to try parent joint meshes to actual joint nodes each frame (in case joints appear later)
  function tryAttachJointMeshes() {
    for (let i=0;i<2;i++){
      const hand = xrHands[i];
      for (const name of jointNames) {
        const mesh = jointMeshes[i][name];
        if (!mesh) continue;
        // if mesh is already parented directly to joint node, continue
        if (mesh.parent && mesh.parent === (hand.joints && hand.joints[name])) continue;
        // if joint exists now, re-parent and reset local transform
        try {
          if (hand.joints && hand.joints[name]) {
            hand.joints[name].add(mesh);
            mesh.position.set(0,0,0);
            mesh.quaternion.set(0,0,0,1);
          }
        } catch(e){}
      }
    }
  }

  // ---- Hand interaction basics (pinch/shoot/rub) ----
  // Very similar to previous logic; simplified here so focus is on enabling hands & visuals.
  const handState = [{ pos:new THREE.Vector3(), prevPos:new THREE.Vector3(), pinch:false, pinchStart:0 }, { pos:new THREE.Vector3(), prevPos:new THREE.Vector3(), pinch:false, pinchStart:0 }];
  const handGrabConstraints = new Map();
  const rubHistory = [];

  function detectPinch(hand) {
    // try common joint names for thumb/index
    const thumb = hand.joints && (hand.joints['thumb-tip'] || hand.joints['thumb-phalanx-tip']);
    const index = hand.joints && (hand.joints['index-finger-tip'] || hand.joints['index-tip']);
    if (!thumb || !index) return { pinch:false, thumbP:null, indexP:null, distance:999 };
    try {
      const t = new THREE.Vector3().setFromMatrixPosition(thumb.matrixWorld);
      const i = new THREE.Vector3().setFromMatrixPosition(index.matrixWorld);
      const d = t.distanceTo(i);
      return { pinch: d < 0.045, thumbP: t, indexP: i, distance:d };
    } catch(e) { return { pinch:false, thumbP:null, indexP:null, distance:999 }; }
  }

  function estimateHandForward(hand) {
    const wrist = hand.joints && (hand.joints['wrist']);
    const index = hand.joints && (hand.joints['index-finger-tip'] || hand.joints['index-tip']);
    const thumb = hand.joints && (hand.joints['thumb-tip']);
    const dir = new THREE.Vector3();
    try {
      if (wrist && index) {
        const w = new THREE.Vector3().setFromMatrixPosition(wrist.matrixWorld);
        const it = new THREE.Vector3().setFromMatrixPosition(index.matrixWorld);
        dir.copy(it).sub(w).normalize();
      } else if (index && thumb) {
        const it = new THREE.Vector3().setFromMatrixPosition(index.matrixWorld);
        const th = new THREE.Vector3().setFromMatrixPosition(thumb.matrixWorld);
        dir.copy(it).sub(th).normalize();
      } else {
        camera.getWorldDirection(dir);
      }
    } catch(e){ camera.getWorldDirection(dir); }
    // soften vertical bias
    if (Math.abs(dir.y) > 0.85) { dir.y *= 0.5; dir.normalize(); }
    return dir;
  }

  function handShootFromMuzzle(muzzlePos, hand) {
    const dir = estimateHandForward(hand);
    const hit = raycastBodies(muzzlePos, dir, 40);
    if (hit) {
      hit.body.applyImpulse(new CANNON.Vec3(dir.x, dir.y, dir.z).scale(8), hit.body.position);
    } else {
      const p = new THREE.Mesh(new THREE.SphereGeometry(0.05,8,8), new THREE.MeshStandardMaterial({ color:0xffdd66 }));
      scene.add(p);
      const spawn = muzzlePos.clone().add(dir.clone().multiplyScalar(0.06));
      p.position.copy(spawn);
      const pb = new CANNON.Body({ mass:0.18, shape: new CANNON.Sphere(0.05), position:new CANNON.Vec3(spawn.x, spawn.y, spawn.z), material: defaultMat });
      pb.velocity.set(dir.x*24, dir.y*24, dir.z*24);
      world.addBody(pb);
      interactMeshes.push(p); interactBodies.push(pb);
      setTimeout(()=> { try { scene.remove(p); world.removeBody(pb); } catch(e){} }, 6000);
    }
  }

  function raycastBodies(origin, direction, maxDist=30) {
    let best=null, bestDist=Infinity;
    for (const b of [sphereBody, ...interactBodies]) {
      if (b.type === CANNON.Body.STATIC) continue;
      const pos = new THREE.Vector3(b.position.x, b.position.y, b.position.z);
      const to = pos.clone().sub(origin);
      const proj = to.dot(direction);
      if (proj < 0 || proj > maxDist) continue;
      const perp = to.clone().sub(direction.clone().multiplyScalar(proj)).length();
      const radius = (b.shapes[0] instanceof CANNON.Sphere) ? b.shapes[0].radius : 0.35;
      if (perp <= radius + 0.12 && proj < bestDist) { bestDist = proj; best = { body:b, hitPoint: origin.clone().add(direction.clone().multiplyScalar(proj)), dist: proj }; }
    }
    return best;
  }

  // simple grab using point-to-point constraint (sustained pinch)
  function startHandGrab(i, pos) {
    if (handGrabConstraints.has(i)) return;
    let best=null, bd=999;
    for (const b of [sphereBody, ...interactBodies]) {
      const d = pos.distanceTo(new THREE.Vector3(b.position.x,b.position.y,b.position.z));
      if (d < 0.28 && d < bd) { bd = d; best = b; }
    }
    if (!best) return;
    const ctrl = new CANNON.Body({ mass:0, type:CANNON.Body.KINEMATIC });
    ctrl.position.copy(new CANNON.Vec3(pos.x, pos.y, pos.z));
    world.addBody(ctrl);
    const pivot = best.pointToLocalFrame(new CANNON.Vec3(pos.x,pos.y,pos.z));
    const constraint = new CANNON.PointToPointConstraint(best, pivot, ctrl, new CANNON.Vec3(0,0,0));
    world.addConstraint(constraint);
    handGrabConstraints.set(i, { constraint, ctrlBody: ctrl, targetBody: best });
  }
  function endHandGrab(i, throwDir=null) {
    const d = handGrabConstraints.get(i);
    if (!d) return;
    if (throwDir) d.targetBody.applyImpulse(new CANNON.Vec3(throwDir.x, throwDir.y, throwDir.z).scale(2.5), d.targetBody.position);
    try { world.removeConstraint(d.constraint); world.removeBody(d.ctrlBody); } catch(e){}
    handGrabConstraints.delete(i);
  }

  function updateHandKinematics() {
    for (const [i, data] of handGrabConstraints) {
      const p = handState[i].pos;
      data.ctrlBody.position.copy(new CANNON.Vec3(p.x, p.y, p.z));
    }
  }

  // rubbing detection
  function addRubSample(dist, t) {
    rubHistory.push({ dist, t });
    if (rubHistory.length > 14) rubHistory.shift();
  }
  function computeRubIntensity() {
    if (rubHistory.length < 6) return 0;
    let sumAbs=0;
    for (let i=1;i<rubHistory.length;i++){
      const dt = Math.max(1e-4, rubHistory[i].t - rubHistory[i-1].t);
      sumAbs += Math.abs((rubHistory[i].dist - rubHistory[i-1].dist)/dt);
    }
    const avg = sumAbs / (rubHistory.length -1);
    const latest = rubHistory[rubHistory.length-1].dist;
    const closeness = Math.max(0, 1 - (latest / 0.22));
    const intensity = avg * 0.02 * closeness;
    return Math.max(0, Math.min(1.5, intensity));
  }

  // orbiter
  function maintainOrbit(dt) {
    let grabbed=false; for (const v of handGrabConstraints.values()) if (v.targetBody === sphereBody) grabbed=true;
    if (grabbed) return;
    const center = centralBody.position; const orbitalRadius = 2.0; const spd = 1.2;
    const t = performance.now()*0.001;
    const des = new CANNON.Vec3(center.x + Math.cos(t*spd)*orbitalRadius, 1.0 + Math.sin(t*0.5)*0.3, center.z + Math.sin(t*spd)*orbitalRadius);
    const kp=20, kd=3;
    const pos = sphereBody.position, vel = sphereBody.velocity;
    sphereBody.applyForce(new CANNON.Vec3((des.x-pos.x)*kp - vel.x*kd, (des.y-pos.y)*kp - vel.y*kd, (des.z-pos.z)*kp - vel.z*kd), pos);
  }

  // sync physics -> visuals
  function syncPhysicsGraphics() {
    if (renderer.xr.isPresenting) {
      const head = new THREE.Vector3(); camera.getWorldPosition(head);
      playerBody.position.x = head.x; playerBody.position.z = head.z;
      playerBody.position.y = Math.max(0.3, head.y - 0.55);
      playerBody.velocity.set(0,0,0);
    } else {
      rig.position.set(playerBody.position.x, playerBody.position.y + 0.0, playerBody.position.z);
      camera.position.set(0,0.6,0);
    }
    sphereMesh.position.copy(sphereBody.position); sphereMesh.quaternion.copy(sphereBody.quaternion);
    centralMesh.position.copy(centralBody.position); centralMesh.quaternion.copy(centralBody.quaternion);
    for (let i=0;i<interactMeshes.length;i++){ interactMeshes[i].position.copy(interactBodies[i].position); interactMeshes[i].quaternion.copy(interactBodies[i].quaternion); }
  }

  // ---- XR session creation that requests hand-tracking ----
  const xrBtn = document.getElementById('xrBtn');
  xrBtn.addEventListener('click', async () => {
    if (!navigator.xr) {
      alert('WebXR not available in this browser.');
      return;
    }
    try {
      // prefer immersive-vr and request hand-tracking as optional feature
      const session = await navigator.xr.requestSession('immersive-vr', {
        optionalFeatures: ['local-floor', 'hand-tracking', 'bounded-floor', 'layers']
      });
      await renderer.xr.setSession(session);
      console.log('XR session started. Hand-tracking requested.');
      // create joint visuals once session started
      createJointVisualsForSession(session);
    } catch (err) {
      console.warn('Failed to start XR session with hands:', err);
      // fallback: try a plain session without hand-tracking
      try {
        const session2 = await navigator.xr.requestSession('immersive-vr', { optionalFeatures: ['local-floor','bounded-floor'] });
        await renderer.xr.setSession(session2);
        console.log('XR fallback session started (no hand-tracking requested).');
      } catch(e){ console.error('XR fallback failed:', e); alert('Unable to start XR session.'); }
    }
  });

  // ---- main loop ----
  let last = null; const fixedStep = 1/60;
  function animate(ts) {
    renderer.setAnimationLoop(animate);
    const t = ts ? ts/1000 : performance.now()/1000;
    if (!last) last = t;
    const dt = Math.min(1/30, t - last);
    last = t;

    // try attaching joint meshes to real joint nodes if they became available
    tryAttachJointMeshes();

    // update hand states (0 & 1)
    const headPos = new THREE.Vector3(); camera.getWorldPosition(headPos);
    for (let i=0;i<2;i++){
      const hand = xrHands[i];
      const pin = detectPinch(hand);
      const pos = (pin.indexP ? pin.indexP.clone() : (pin.thumbP ? pin.thumbP.clone() : (hand.joints && hand.joints['wrist'] ? new THREE.Vector3().setFromMatrixPosition(hand.joints['wrist'].matrixWorld) : new THREE.Vector3())));
      handState[i].prevPos.copy(handState[i].pos); handState[i].pos.copy(pos);
      const now = t;
      if (pin.pinch && !handState[i].pinch) { handState[i].pinch = true; handState[i].pinchStart = now; }
      else if (!pin.pinch && handState[i].pinch) {
        const held = now - handState[i].pinchStart;
        // quick pinch = shoot from muzzle at joint mesh if exists, or index tip
        const muzzle = (jointMeshes[i]['index-finger-tip'] && jointMeshes[i]['index-finger-tip'].getWorldPosition) ? new THREE.Vector3().setFromMatrixPosition(jointMeshes[i]['index-finger-tip'].matrixWorld) : handState[i].pos.clone();
        if (held < 0.22) {
          handShootFromMuzzle(muzzle, hand);
        } else {
          const throwDir = estimateHandForward(hand).clone();
          endHandGrab(i, throwDir);
        }
        handState[i].pinch = false;
      } else if (pin.pinch && handState[i].pinch) {
        const held = now - handState[i].pinchStart;
        if (held > 0.18 && !handGrabConstraints.has(i)) startHandGrab(i, handState[i].pos);
      }
    }

    // rubbing
    const left = handState[0].pos.clone(); const right = handState[1].pos.clone();
    const palmDist = left.distanceTo(right);
    addRubSample(palmDist, t);
    const rubIntensity = computeRubIntensity();
    if (rubIntensity > 0.03) {
      const camF = new THREE.Vector3(); camera.getWorldDirection(camF); camF.y = 0; camF.normalize();
      const nudge = 0.02 * (rubIntensity * 2.5);
      if (renderer.xr.isPresenting) {
        playerBody.position.x += camF.x * nudge; playerBody.position.z += camF.z * nudge;
      } else {
        playerBody.velocity.x += camF.x * nudge * 12; playerBody.velocity.z += camF.z * nudge * 12;
      }
    }

    // update kinematic grabs
    updateHandKinematics();

    // orbit
    maintainOrbit(dt);

    // step physics
    world.step(fixedStep, dt, 4);

    // sync visuals
    syncPhysicsGraphics();

    renderer.render(scene, camera);
  }
  renderer.setAnimationLoop(animate);

  // resize
  window.addEventListener('resize', ()=> { camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); });

  // expose spawn for debug
  window.spawnBox = spawnBox;
  console.log('Page ready â€” press the "Enter VR (request hands)" button. If your browser supports hand-tracking the joint spheres should appear.');

  </script>
</body>
</html>
