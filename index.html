<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Hand-only VR â€” Hand Blasters + Rubbing Walk</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { margin:0; overflow:hidden; font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif; }
    #info {
      position: absolute; left: 10px; top: 10px; padding:10px 14px; background: rgba(0,0,0,0.45);
      color: #fff; border-radius:8px; max-width:360px; line-height:1.2;
    }
    #info b { color:#ffd; }
  </style>
</head>
<body>
  <div id="info">
    Hand-only mode: Pinch (thumb+index) to shoot from that hand. <br>
    Rub your hands together to move forward (closer & fast = stronger). <br>
    Desktop fallback: click to lock pointer, WASD to move, X to spawn a block.
  </div>

  <script type="module">
  import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js';
  import { VRButton } from 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/webxr/VRButton.js';
  import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

  // --- three + renderer ---
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x081018);
  const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.05, 1000);
  const renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setSize(innerWidth, innerHeight);
  renderer.xr.enabled = true;
  renderer.shadowMap.enabled = true;
  document.body.appendChild(renderer.domElement);
  document.body.appendChild(VRButton.createButton(renderer));

  // lighting
  const hemi = new THREE.HemisphereLight(0xffffff, 0x222244, 0.8); hemi.position.set(0,10,0); scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 0.6); dir.position.set(3,10,6); dir.castShadow = true; scene.add(dir);

  // rig & camera
  const rig = new THREE.Group();
  rig.add(camera);
  scene.add(rig);

  // --- cannon world ---
  const world = new CANNON.World({ gravity: new CANNON.Vec3(0,-9.82,0) });
  world.broadphase = new CANNON.SAPBroadphase(world);
  world.solver.iterations = 10;
  const defaultMat = new CANNON.Material('default');
  world.addContactMaterial(new CANNON.ContactMaterial(defaultMat, defaultMat, { friction:0.5, restitution:0.05 }));

  // ground
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(120,120), new THREE.MeshStandardMaterial({ color:0x263238 }));
  ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);
  const groundBody = new CANNON.Body({ type: CANNON.Body.STATIC, shape: new CANNON.Plane(), material: defaultMat });
  groundBody.quaternion.setFromEuler(-Math.PI/2,0,0); world.addBody(groundBody);

  // central cube + orbit sphere (same as before)
  const centralMesh = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshStandardMaterial({ color:0xff4444 }));
  centralMesh.position.set(0,0.5,0); centralMesh.castShadow = true; scene.add(centralMesh);
  const centralBody = new CANNON.Body({ type: CANNON.Body.STATIC, shape: new CANNON.Box(new CANNON.Vec3(0.5,0.5,0.5)), position: new CANNON.Vec3(0,0.5,0), material: defaultMat });
  world.addBody(centralBody);

  const sphereMesh = new THREE.Mesh(new THREE.SphereGeometry(0.4,32,32), new THREE.MeshStandardMaterial({ color:0x00ff88 }));
  sphereMesh.castShadow = true; scene.add(sphereMesh);
  const sphereBody = new CANNON.Body({ mass:1, shape: new CANNON.Sphere(0.4), position: new CANNON.Vec3(2,1,0), material: defaultMat });
  world.addBody(sphereBody);

  // interactable lists
  const interactMeshes = [];
  const interactBodies = [];
  function spawnBox(x,y,z,color=0x4488ff,mass=2){
    const m = new THREE.Mesh(new THREE.BoxGeometry(0.6,0.6,0.6), new THREE.MeshStandardMaterial({ color }));
    m.castShadow=true; m.position.set(x,y,z); scene.add(m); interactMeshes.push(m);
    const b = new CANNON.Body({ mass, shape: new CANNON.Box(new CANNON.Vec3(0.3,0.3,0.3)), position:new CANNON.Vec3(x,y,z), material: defaultMat });
    world.addBody(b); interactBodies.push(b);
    return { m,b };
  }

  // two static blocks
  spawnBox(-3,0.375,-1.5,0x4455aa,0).m.receiveShadow=true; // mass 0 => static (spawnBox expects mass param but sets mass)
  spawnBox(3,0.6,-2,0xaa5544,0).m.receiveShadow=true;

  // initial interactables
  spawnBox(1.5,1,-1,0x4488ff,2);
  spawnBox(-1.5,1,-1,0xffaa33,2);
  spawnBox(0,2,-2,0x00ffaa,2);

  // player physics body to push objects
  const playerBody = new CANNON.Body({ mass:1, shape: new CANNON.Sphere(0.35), position: new CANNON.Vec3(0,1.0,4), fixedRotation:true, material: defaultMat });
  playerBody.linearDamping = 0.9; world.addBody(playerBody);

  // helper debug (invisible)
  const playerDebug = new THREE.Mesh(new THREE.SphereGeometry(0.35,8,8), new THREE.MeshBasicMaterial({ visible:false }));
  scene.add(playerDebug);

  // movement variables
  const speed = 3.0;
  let canJump = false;
  const moveState = { forward:0, right:0, jump:false };

  // desktop fallback controls
  const keys = {};
  window.addEventListener('keydown', e => {
    keys[e.code] = true;
    if (e.code === 'KeyW') moveState.forward = 1;
    if (e.code === 'KeyS') moveState.forward = -1;
    if (e.code === 'KeyA') moveState.right = -1;
    if (e.code === 'KeyD') moveState.right = 1;
    if (e.code === 'Space') moveState.jump = true;
    if (e.code === 'KeyX') { const cp = camera.getWorldPosition(new THREE.Vector3()); const dir = camera.getWorldDirection(new THREE.Vector3()); spawnBox(cp.x + dir.x*1.2, cp.y + 0.4, cp.z + dir.z*1.2, 0xff88ff, 2); }
  });
  window.addEventListener('keyup', e => {
    keys[e.code] = false;
    if (!keys['KeyW'] && !keys['KeyS']) moveState.forward = 0;
    if (!keys['KeyA'] && !keys['KeyD']) moveState.right = 0;
    if (e.code === 'Space') moveState.jump = false;
  });
  document.addEventListener('click', ()=> renderer.domElement.requestPointerLock?.());

  // --- HAND-ONLY setup ---
  // We will hide controllers and only use XRHand joints.
  const xrHand0 = renderer.xr.getHand(0);
  const xrHand1 = renderer.xr.getHand(1);
  scene.add(xrHand0, xrHand1);

  // hand visual groups (spheres to show wrist/thumb/index and muzzle)
  function makeHandVisualGroup(color) {
    const g = new THREE.Group();
    const wrist = new THREE.Mesh(new THREE.SphereGeometry(0.04,8,8), new THREE.MeshStandardMaterial({ color }));
    const thumb = new THREE.Mesh(new THREE.SphereGeometry(0.03,8,8), new THREE.MeshStandardMaterial({ color:0xffeebb }));
    const index = new THREE.Mesh(new THREE.SphereGeometry(0.03,8,8), new THREE.MeshStandardMaterial({ color:0xccffcc }));
    const muzzle = new THREE.Mesh(new THREE.SphereGeometry(0.04,12,12), new THREE.MeshStandardMaterial({ color:0xffdd66 }));
    muzzle.visible = true;
    g.add(wrist, thumb, index, muzzle);
    return { group: g, wrist, thumb, index, muzzle };
  }

  const hand0Vis = makeHandVisualGroup(0xff9966);
  const hand1Vis = makeHandVisualGroup(0x66ccff);
  scene.add(hand0Vis.group, hand1Vis.group);

  // hide controllers if present
  const controllerA = renderer.xr.getController(0);
  const controllerB = renderer.xr.getController(1);
  controllerA.visible = controllerB.visible = false;

  // track hand state history for pinch & rubbing
  const handState = [
    { pinch:false, pinchStart:0, pos: new THREE.Vector3(), prevPos: new THREE.Vector3(), vel: new THREE.Vector3(), distToHead:0 },
    { pinch:false, pinchStart:0, pos: new THREE.Vector3(), prevPos: new THREE.Vector3(), vel: new THREE.Vector3(), distToHead:0 }
  ];

  // helper: get joint world position safely
  function getJointPosition(hand, jointName) {
    try {
      const j = hand.joints && hand.joints[jointName];
      if (j && j.visible) {
        const p = new THREE.Vector3(); p.setFromMatrixPosition(j.matrixWorld); return p;
      }
    } catch(e){}
    // fallback to hand group position
    const tmp = new THREE.Vector3(); hand.getWorldPosition(tmp); return tmp;
  }

  // Helper to detect pinch (thumb+index close)
  function detectPinch(hand, idx) {
    // possible joint names vary; try common ones
    const thumbNames = ['thumb-tip','thumb-phalanx-tip','thumb-tip'];
    const indexNames = ['index-finger-tip','index-finger-phalanx-tip','index-tip'];
    let thumbP=null, indexP=null;
    for (const n of thumbNames) { try { if (hand.joints && hand.joints[n]) { thumbP = new THREE.Vector3().setFromMatrixPosition(hand.joints[n].matrixWorld); break; } } catch(e){} }
    for (const n of indexNames) { try { if (hand.joints && hand.joints[n]) { indexP = new THREE.Vector3().setFromMatrixPosition(hand.joints[n].matrixWorld); break; } } catch(e){} }
    if (!thumbP || !indexP) {
      // fallback to relative small distance between approximate points
      thumbP = getJointPosition(hand, 'thumb-tip'); indexP = getJointPosition(hand, 'index-finger-tip');
    }
    const d = thumbP.distanceTo(indexP);
    return { pinch: d < 0.045, thumbP, indexP, distance: d };
  }

  // Raycast bodies helper
  function raycastBodies(origin, direction, maxDist=30) {
    let best = null; let bestDist = Infinity;
    for (const b of [sphereBody, ...interactBodies]) {
      if (b.type === CANNON.Body.STATIC) continue;
      const pos = new THREE.Vector3(b.position.x, b.position.y, b.position.z);
      const to = pos.clone().sub(origin);
      const proj = to.dot(direction);
      if (proj < 0 || proj > maxDist) continue;
      const perp = to.clone().sub(direction.clone().multiplyScalar(proj)).length();
      const radius = (b.shapes[0] instanceof CANNON.Sphere) ? b.shapes[0].radius : 0.35;
      if (perp <= radius + 0.12 && proj < bestDist) { bestDist = proj; best = { body: b, hitPoint: origin.clone().add(direction.clone().multiplyScalar(proj)), dist: proj }; }
    }
    return best;
  }

  // shoot from a given hand: origin = hand pos, direction = (handPos - headPos).normalize()
  function handShoot(handIndex, handPos) {
    const headPos = new THREE.Vector3(); camera.getWorldPosition(headPos);
    const dir = handPos.clone().sub(headPos).normalize();
    // slight safety: if dir is zero, use camera forward
    if (dir.length() < 0.0001) camera.getWorldDirection(dir);
    // try to hit dynamic body
    const hit = raycastBodies(handPos, dir, 40);
    if (hit) {
      const impulse = new CANNON.Vec3(dir.x, dir.y, dir.z).scale(8);
      hit.body.applyImpulse(impulse, hit.body.position);
    } else {
      // spawn projectile from hand
      const pGeo = new THREE.SphereGeometry(0.05,8,8);
      const pMat = new THREE.MeshStandardMaterial({ color:0xffdd66 });
      const pMesh = new THREE.Mesh(pGeo, pMat); pMesh.castShadow = true; scene.add(pMesh);
      const spawn = handPos.clone().add(dir.clone().multiplyScalar(0.08));
      pMesh.position.copy(spawn);
      const pBody = new CANNON.Body({ mass:0.18, shape: new CANNON.Sphere(0.05), position: new CANNON.Vec3(spawn.x, spawn.y, spawn.z), material: defaultMat });
      pBody.velocity.set(dir.x*24, dir.y*24, dir.z*24);
      world.addBody(pBody);
      interactMeshes.push(pMesh); interactBodies.push(pBody);
      setTimeout(()=> { try { scene.remove(pMesh); world.removeBody(pBody); } catch(e){} }, 6000);
    }
  }

  // grabbing via sustained pinch -> point-to-point constraint
  const handGrabConstraints = new Map(); // index -> { constraint, ctrlBody, targetBody, pinchStart }

  function startHandGrab(index, handPos) {
    if (handGrabConstraints.has(index)) return;
    // find nearby body within 0.28 m
    let best=null, bd=999;
    for (const b of [sphereBody, ...interactBodies]) {
      const d = handPos.distanceTo(new THREE.Vector3(b.position.x,b.position.y,b.position.z));
      if (d < 0.28 && d < bd) { bd = d; best = b; }
    }
    if (!best) return;
    const ctrl = new CANNON.Body({ mass:0, type: CANNON.Body.KINEMATIC });
    ctrl.position.copy(new CANNON.Vec3(handPos.x, handPos.y, handPos.z));
    world.addBody(ctrl);
    const pivot = best.pointToLocalFrame(new CANNON.Vec3(handPos.x, handPos.y, handPos.z));
    const constraint = new CANNON.PointToPointConstraint(best, pivot, ctrl, new CANNON.Vec3(0,0,0));
    world.addConstraint(constraint);
    handGrabConstraints.set(index, { constraint, ctrlBody: ctrl, targetBody: best });
  }

  function endHandGrab(index, throwDir=null) {
    const data = handGrabConstraints.get(index);
    if (!data) return;
    if (throwDir) {
      data.targetBody.applyImpulse(new CANNON.Vec3(throwDir.x, throwDir.y, throwDir.z).scale(2.5), data.targetBody.position);
    }
    try { world.removeConstraint(data.constraint); world.removeBody(data.ctrlBody); } catch(e){}
    handGrabConstraints.delete(index);
  }

  // update kinematic controllers for grab constraints to follow current hand positions
  function updateHandKinematics() {
    for (const [idx, data] of handGrabConstraints) {
      const p = handState[idx].pos;
      data.ctrlBody.position.copy(new CANNON.Vec3(p.x, p.y, p.z));
    }
  }

  // rubbing detection: keep history of last N distances and compute alternating velocity
  const rubHistory = []; // store last ~12 distances between palms and timestamps
  function addRubSample(dist, t) {
    rubHistory.push({ dist, t });
    if (rubHistory.length > 14) rubHistory.shift();
  }
  function computeRubIntensity() {
    if (rubHistory.length < 6) return 0;
    // compute average absolute derivative and oscillation amount
    let sumAbsDeriv = 0;
    for (let i=1;i<rubHistory.length;i++){
      const dt = Math.max(1e-4, rubHistory[i].t - rubHistory[i-1].t);
      sumAbsDeriv += Math.abs((rubHistory[i].dist - rubHistory[i-1].dist)/dt);
    }
    const avgDeriv = sumAbsDeriv / (rubHistory.length - 1);
    // also penalize if hands are not close enough (we want rubbing when distance small)
    const latest = rubHistory[rubHistory.length -1].dist;
    const closeness = Math.max(0, 1 - (latest / 0.22)); // 1 when within 0, 0 at 0.22m
    const intensity = avgDeriv * 0.02 * closeness; // tuned factor
    return Math.max(0, Math.min(1.5, intensity)); // clamp
  }

  // orbit maintain for the sphere (unchanged)
  function maintainOrbit(dt) {
    let grabbed=false; for (const v of handGrabConstraints.values()) if (v.targetBody === sphereBody) grabbed=true;
    if (grabbed) return;
    const center = centralBody.position; const orbitalRadius = 2.0; const speedOrbit = 1.2;
    const t = performance.now()*0.001;
    const des = new CANNON.Vec3(center.x + Math.cos(t*speedOrbit)*orbitalRadius, 1.0 + Math.sin(t*0.5)*0.3, center.z + Math.sin(t*speedOrbit)*orbitalRadius);
    const kp=20, kd=3;
    const pos = sphereBody.position, vel = sphereBody.velocity;
    sphereBody.applyForce(new CANNON.Vec3((des.x-pos.x)*kp - vel.x*kd, (des.y-pos.y)*kp - vel.y*kd, (des.z-pos.z)*kp - vel.z*kd), pos);
  }

  // cannon ground detection for jump
  world.addEventListener('postStep', ()=> {
    canJump = false;
    const from = playerBody.position.clone();
    const to = playerBody.position.clone().vsub(new CANNON.Vec3(0,0.8,0));
    const ray = new CANNON.Ray(from,to);
    const res = new CANNON.RaycastResult();
    ray.intersectWorld(world, { skipBackfaces:true }, res);
    if (res.hasHit) canJump = true;
  });

  // sync physics -> graphics
  function syncPhysicsGraphics() {
    // when in XR: playerBody position should follow the head horizontally (so head pushes objects)
    if (renderer.xr.isPresenting) {
      const head = new THREE.Vector3(); camera.getWorldPosition(head);
      playerBody.position.x = head.x; playerBody.position.z = head.z;
      playerBody.position.y = Math.max(0.3, head.y - 0.55); // keep player lower than head
      playerBody.velocity.set(0,0,0);
    } else {
      rig.position.set(playerBody.position.x, playerBody.position.y + 0.0, playerBody.position.z);
      camera.position.set(0,0.6,0);
    }
    sphereMesh.position.copy(sphereBody.position); sphereMesh.quaternion.copy(sphereBody.quaternion);
    centralMesh.position.copy(centralBody.position); centralMesh.quaternion.copy(centralBody.quaternion);
    for (let i=0;i<interactMeshes.length;i++){ interactMeshes[i].position.copy(interactBodies[i].position); interactMeshes[i].quaternion.copy(interactBodies[i].quaternion); }
    playerDebug.position.copy(playerBody.position);
  }

  // desktop camera orientation compute
  let yaw=0, pitch=0, pointerLocked=false;
  document.addEventListener('mousemove', e => { if (!pointerLocked) return; yaw -= e.movementX*0.0025; pitch -= e.movementY*0.0025; pitch = Math.max(-Math.PI/2+0.05, Math.min(Math.PI/2-0.05, pitch)); });
  document.addEventListener('click', ()=> renderer.domElement.requestPointerLock?.());
  document.addEventListener('pointerlockchange', ()=> pointerLocked = document.pointerLockElement === renderer.domElement);

  // main loop
  let last = null; const fixedStep = 1/60;
  function animate(time) {
    renderer.setAnimationLoop(animate);
    const t = time ? time/1000 : performance.now()/1000;
    if (!last) last = t;
    const dt = Math.min(1/30, t - last);
    last = t;

    // update hand states (for both hands)
    const hands = [xrHand0, xrHand1];
    const headPos = new THREE.Vector3(); camera.getWorldPosition(headPos);

    for (let i=0;i<2;i++){
      const hand = hands[i];
      // world joint positions
      const thumbNames = ['thumb-tip','thumb-tip'];
      const indexNames = ['index-finger-tip','index-tip','index-finger-phalanx-tip'];
      // detect pinch
      const pin = detectPinch(hand, i);
      const posEstimate = getJointPosition(hand, 'wrist') || (pin.indexP || pin.thumbP || new THREE.Vector3());
      handState[i].prevPos.copy(handState[i].pos);
      handState[i].pos.copy(posEstimate);
      const dtPos = Math.max(1e-4, dt);
      handState[i].vel.copy(handState[i].pos).sub(handState[i].prevPos).divideScalar(dtPos);
      handState[i].distToHead = handState[i].pos.distanceTo(headPos);

      // update visuals
      const hv = (i===0) ? hand0Vis : hand1Vis;
      hv.group.visible = true; // show hand visuals in hand-only mode
      // place wrist at estimate, thumb/index at pinch pts if available
      try { hv.wrist.position.copy(getJointPosition(hand,'wrist')); } catch(e){}
      if (pin.thumbP) hv.thumb.position.copy(pin.thumbP);
      if (pin.indexP) hv.index.position.copy(pin.indexP);
      hv.muzzle.position.copy(handState[i].pos); // muzzle at hand position

      // pinch detection transitions
      const now = t;
      if (pin.pinch && !handState[i].pinch) {
        // pinch start
        handState[i].pinch = true; handState[i].pinchStart = now;
      } else if (!pin.pinch && handState[i].pinch) {
        // pinch end => determine whether it was a quick tap (shoot) or a grab (sustained)
        const held = now - handState[i].pinchStart;
        if (held < 0.22) {
          // quick pinch -> shot
          handShoot(i, handState[i].pos);
        } else {
          // release after grab -> throw in direction head->hand
          const throwDir = handState[i].pos.clone().sub(headPos).normalize();
          endHandGrab(i, throwDir);
        }
        handState[i].pinch = false;
      } else if (pin.pinch && handState[i].pinch) {
        // still pinching: if held long enough and not yet grabbing, start a grab
        const held = now - handState[i].pinchStart;
        if (held > 0.18 && !handGrabConstraints.has(i)) {
          // start a hand grab
          startHandGrab(i, handState[i].pos);
        }
      }
    }

    // rubbing detection: measure palm-to-palm distance (use wrist or index positions)
    const leftPos = handState[0].pos.clone();
    const rightPos = handState[1].pos.clone();
    const palmDist = leftPos.distanceTo(rightPos);
    addRubSample(palmDist, t);
    const rubIntensity = computeRubIntensity(); // 0.. ~1.5

    // if rubbing intensity detected, push player forward relative to camera
    if (rubIntensity > 0.03) {
      // move playerBody forward gently proportionally to rubIntensity
      const camF = new THREE.Vector3(); camera.getWorldDirection(camF); camF.y = 0; camF.normalize();
      // stronger rub -> stronger forward nudge
      const nudge = 0.02 * (rubIntensity * 2.5); // tuned
      // apply by nudging playerBody position (XR) or adding velocity (desktop)
      if (renderer.xr.isPresenting) {
        playerBody.position.x += camF.x * nudge;
        playerBody.position.z += camF.z * nudge;
      } else {
        playerBody.velocity.x += camF.x * nudge * 12;
        playerBody.velocity.z += camF.z * nudge * 12;
      }
    }

    // update hand-grab kinematics
    updateHandKinematics();

    // maintain orbit sphere
    maintainOrbit(dt);

    // step physics
    world.step(fixedStep, dt, 4);

    // sync physics -> graphics
    syncPhysicsGraphics();

    // desktop camera orientation
    if (!renderer.xr.isPresenting) {
      camera.quaternion.setFromEuler(new THREE.Euler(pitch || 0, yaw || 0, 0, 'YXZ'));
    }

    renderer.render(scene, camera);
  }
  renderer.setAnimationLoop(animate);

  // resize
  window.addEventListener('resize', ()=> { camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); });

  // expose some helpers for debugging
  window.spawnBox = spawnBox;
  window.playerBody = playerBody;
  window.handStateDebug = handState;

  console.log('Hand-only VR loaded. Use pinch to shoot or grab; rub hands to move forward.');

  </script>
</body>
</html>
