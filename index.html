<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Hand VR â€” Both Triggers Move Forward</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { margin:0; overflow:hidden; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
    #info {
      position: absolute; left: 10px; top: 10px; padding:10px 14px; background: rgba(0,0,0,0.45);
      color: #fff; border-radius:8px; max-width:420px; line-height:1.2;
    }
    #enterVr {
      position: absolute; right: 10px; top: 10px; z-index: 10;
      padding: 10px 16px; background: #1e88e5; color: white; border: none; border-radius: 8px; font-size: 16px;
    }
    #log { position: absolute; left:10px; bottom:10px; background: rgba(0,0,0,0.35); color:#ddd; padding:8px 10px; border-radius:6px; font-size:12px; max-width: 420px; }
  </style>
</head>
<body>
  <div id="info"><b>Hand-tracking:</b> Enter VR using the button. Pinch to shoot/grab. Hold the trigger with <b>both hands</b> to move forward.</div>
  <button id="enterVr">Enter VR (hand-tracking)</button>
  <div id="log">Status: idle</div>

  <script type="module">
  import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js';
  import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

  // --- three + cannon setup ---
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x081018);
  const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.05, 1000);
  const renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setSize(innerWidth, innerHeight);
  renderer.xr.enabled = true;
  renderer.shadowMap.enabled = true;
  document.body.appendChild(renderer.domElement);

  const logEl = document.getElementById('log');
  function log(s){ logEl.textContent = 'Status: ' + s; console.log(s); }

  // lights
  scene.add(new THREE.HemisphereLight(0xffffff, 0x222244, 0.8));
  const dl = new THREE.DirectionalLight(0xffffff, 0.6); dl.position.set(3,10,6); dl.castShadow = true; scene.add(dl);

  // cannon world
  const world = new CANNON.World({ gravity: new CANNON.Vec3(0,-9.82,0) });
  world.broadphase = new CANNON.SAPBroadphase(world);
  world.solver.iterations = 10;
  const defaultMat = new CANNON.Material('default');
  world.addContactMaterial(new CANNON.ContactMaterial(defaultMat, defaultMat, { friction: 0.5, restitution: 0.05 }));

  // ground
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(120,120), new THREE.MeshStandardMaterial({ color:0x263238 }));
  ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);
  const groundBody = new CANNON.Body({ type:CANNON.Body.STATIC, shape:new CANNON.Plane(), material: defaultMat });
  groundBody.quaternion.setFromEuler(-Math.PI/2,0,0); world.addBody(groundBody);

  // central + orbiting sphere
  const centralMesh = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshStandardMaterial({ color:0xff4444 }));
  centralMesh.position.set(0,0.5,0); centralMesh.castShadow = true; scene.add(centralMesh);
  const centralBody = new CANNON.Body({ type:CANNON.Body.STATIC, shape:new CANNON.Box(new CANNON.Vec3(0.5,0.5,0.5)), position:new CANNON.Vec3(0,0.5,0), material:defaultMat });
  world.addBody(centralBody);

  const sphereMesh = new THREE.Mesh(new THREE.SphereGeometry(0.4,32,32), new THREE.MeshStandardMaterial({ color:0x00ff88 }));
  sphereMesh.castShadow = true; scene.add(sphereMesh);
  const sphereBody = new CANNON.Body({ mass:1, shape:new CANNON.Sphere(0.4), position:new CANNON.Vec3(2,1,0), material:defaultMat });
  world.addBody(sphereBody);

  // interactables arrays
  const interactMeshes = [], interactBodies = [];
  function spawnBox(x,y,z,color=0x4488ff,mass=2){
    const m = new THREE.Mesh(new THREE.BoxGeometry(0.6,0.6,0.6), new THREE.MeshStandardMaterial({ color }));
    m.castShadow=true; m.position.set(x,y,z); scene.add(m);
    const b = new CANNON.Body({ mass, shape:new CANNON.Box(new CANNON.Vec3(0.3,0.3,0.3)), position:new CANNON.Vec3(x,y,z), material:defaultMat });
    world.addBody(b); interactMeshes.push(m); interactBodies.push(b);
    return { m,b };
  }

  // static blocks
  spawnBox(-3,0.375,-1.5,0x4455aa,0);
  spawnBox(3,0.6,-2,0xaa5544,0);
  // some dynamic boxes
  spawnBox(1.5,1,-1,0x4488ff,2); spawnBox(-1.5,1,-1,0xffaa33,2); spawnBox(0,2,-2,0x00ffaa,2);

  // player body (for headset-push)
  const playerBody = new CANNON.Body({ mass:1, shape:new CANNON.Sphere(0.35), position:new CANNON.Vec3(0,1.0,4), fixedRotation:true, material:defaultMat });
  playerBody.linearDamping = 0.9; world.addBody(playerBody);
  const playerDebug = new THREE.Mesh(new THREE.SphereGeometry(0.35,8,8), new THREE.MeshBasicMaterial({ visible:false }));
  scene.add(playerDebug);

  // hand visuals (simple spheres) - we'll show these when session supports hands
  function makeHandVisual(color){
    const g = new THREE.Group();
    const wrist = new THREE.Mesh(new THREE.SphereGeometry(0.04,8,8), new THREE.MeshStandardMaterial({ color }));
    const thumb = new THREE.Mesh(new THREE.SphereGeometry(0.03,8,8), new THREE.MeshStandardMaterial({ color:0xffeebb }));
    const index = new THREE.Mesh(new THREE.SphereGeometry(0.03,8,8), new THREE.MeshStandardMaterial({ color:0xccffcc }));
    const muzzle = new THREE.Mesh(new THREE.SphereGeometry(0.04,12,12), new THREE.MeshStandardMaterial({ color:0xffdd66 }));
    g.add(wrist, thumb, index, muzzle);
    g.visible = false; scene.add(g);
    return { group:g, wrist, thumb, index, muzzle };
  }
  const handGroups = [ makeHandVisual(0xff9966), makeHandVisual(0x66ccff) ];

  // XR hand refs
  let xrHand0 = null, xrHand1 = null;
  let sessionSupportsHands = false;

  // hand state for logic
  const handState = [
    { pinching:false, pinchStart:0, pos:new THREE.Vector3(), prevPos:new THREE.Vector3(), vel:new THREE.Vector3() },
    { pinching:false, pinchStart:0, pos:new THREE.Vector3(), prevPos:new THREE.Vector3(), vel:new THREE.Vector3() }
  ];

  // palm kinematic bodies so hands physically push objects
  const palmRadius = 0.06;
  const palmBodies = [
    new CANNON.Body({ mass:0, type:CANNON.Body.KINEMATIC, shape:new CANNON.Sphere(palmRadius), position:new CANNON.Vec3(0,-100,0), material: defaultMat }),
    new CANNON.Body({ mass:0, type:CANNON.Body.KINEMATIC, shape:new CANNON.Sphere(palmRadius), position:new CANNON.Vec3(0,-100,0), material: defaultMat })
  ];
  palmBodies.forEach(pb => world.addBody(pb));

  // helper: safe joint fetch
  function getJointPositionSafe(hand, names){
    if (!hand || !hand.joints) return null;
    for (const n of names) {
      try {
        const j = hand.joints[n];
        if (j && j.matrixWorld) return new THREE.Vector3().setFromMatrixPosition(j.matrixWorld);
      } catch(e){}
    }
    // fallback to hand group position
    const tmp = new THREE.Vector3(); hand.getWorldPosition(tmp); return tmp;
  }

  // pinch detection
  function detectPinch(hand){
    const thumbNames = ['thumb-tip','thumb-phalanx-tip','thumb-metacarpal'];
    const indexNames = ['index-finger-tip','index-tip','index-finger-phalanx-tip'];
    const thumbP = getJointPositionSafe(hand, thumbNames);
    const indexP = getJointPositionSafe(hand, indexNames);
    if (!thumbP || !indexP) return { pinch:false, thumbP, indexP, distance:999 };
    const d = thumbP.distanceTo(indexP);
    return { pinch: d < 0.045, thumbP, indexP, distance:d };
  }

  // estimate hand forward direction (wrist->index)
  function estimateHandForward(hand){
    const wrist = getJointPositionSafe(hand, ['wrist','wrist-radius']);
    const indexTip = getJointPositionSafe(hand, ['index-finger-tip','index-tip','index-finger-phalanx-tip']);
    const thumbTip = getJointPositionSafe(hand, ['thumb-tip','thumb-phalanx-tip']);
    const dir = new THREE.Vector3();
    if (wrist && indexTip) dir.copy(indexTip).sub(wrist).normalize();
    else if (indexTip && thumbTip) dir.copy(indexTip).sub(thumbTip).normalize();
    else camera.getWorldDirection(dir);
    if (Math.abs(dir.y) > 0.85) { dir.y *= 0.5; dir.normalize(); }
    return dir;
  }

  // raycast dynamic bodies helper
  function raycastBodies(origin, direction, maxDist=30){
    let best=null, bestDist=Infinity;
    for (const b of [sphereBody, ...interactBodies]){
      if (b.type === CANNON.Body.STATIC) continue;
      const pos = new THREE.Vector3(b.position.x,b.position.y,b.position.z);
      const to = pos.clone().sub(origin);
      const proj = to.dot(direction);
      if (proj < 0 || proj > maxDist) continue;
      const perp = to.clone().sub(direction.clone().multiplyScalar(proj)).length();
      const radius = (b.shapes[0] instanceof CANNON.Sphere) ? b.shapes[0].radius : 0.35;
      if (perp <= radius + 0.12 && proj < bestDist){ bestDist = proj; best = { body:b, hitPoint: origin.clone().add(direction.clone().multiplyScalar(proj)), dist:proj }; }
    }
    return best;
  }

  // shoot from hand muzzle (uses estimateHandForward)
  function handShoot(hand, muzzlePos){
    const dir = estimateHandForward(hand);
    if (dir.length() < 1e-4){ camera.getWorldDirection(dir); dir.y *= 0.1; dir.normalize(); }
    const origin = muzzlePos.clone();
    const hit = raycastBodies(origin, dir, 40);
    if (hit){
      const impulse = new CANNON.Vec3(dir.x, dir.y, dir.z).scale(8);
      hit.body.applyImpulse(impulse, hit.body.position);
    } else {
      const pGeo = new THREE.SphereGeometry(0.05,8,8);
      const pMat = new THREE.MeshStandardMaterial({ color:0xffdd66 });
      const pMesh = new THREE.Mesh(pGeo, pMat); pMesh.castShadow=true; scene.add(pMesh);
      const spawn = origin.clone().add(dir.clone().multiplyScalar(0.08));
      pMesh.position.copy(spawn);
      const pBody = new CANNON.Body({ mass:0.18, shape:new CANNON.Sphere(0.05), position:new CANNON.Vec3(spawn.x, spawn.y, spawn.z), material:defaultMat });
      pBody.velocity.set(dir.x*24, dir.y*24, dir.z*24);
      world.addBody(pBody); interactMeshes.push(pMesh); interactBodies.push(pBody);
      setTimeout(()=>{ try{ scene.remove(pMesh); world.removeBody(pBody); }catch(e){} }, 6000);
    }
  }

  // grabbing via sustained pinch (point-to-point constraint)
  const handGrabConstraints = new Map();
  function startHandGrab(index, pos){
    if (handGrabConstraints.has(index)) return;
    let best=null, bd=999;
    for (const b of [sphereBody, ...interactBodies]) {
      const d = pos.distanceTo(new THREE.Vector3(b.position.x,b.position.y,b.position.z));
      if (d < 0.28 && d < bd) { bd=d; best=b; }
    }
    if (!best) return;
    const ctrl = new CANNON.Body({ mass:0, type:CANNON.Body.KINEMATIC });
    ctrl.position.copy(new CANNON.Vec3(pos.x,pos.y,pos.z));
    world.addBody(ctrl);
    const pivot = best.pointToLocalFrame(new CANNON.Vec3(pos.x,pos.y,pos.z));
    const constraint = new CANNON.PointToPointConstraint(best, pivot, ctrl, new CANNON.Vec3(0,0,0));
    world.addConstraint(constraint);
    handGrabConstraints.set(index, { constraint, ctrlBody:ctrl, targetBody:best });
  }
  function endHandGrab(index, throwDir=null){
    const d = handGrabConstraints.get(index); if (!d) return;
    if (throwDir) d.targetBody.applyImpulse(new CANNON.Vec3(throwDir.x, throwDir.y, throwDir.z).scale(2.5), d.targetBody.position);
    try{ world.removeConstraint(d.constraint); world.removeBody(d.ctrlBody); }catch(e){}
    handGrabConstraints.delete(index);
  }
  function updateHandKinematics(){
    for (const [idx,d] of handGrabConstraints){ const p = handState[idx].pos; d.ctrlBody.position.copy(new CANNON.Vec3(p.x,p.y,p.z)); }
  }

  // ---------- Improved rub detection ----------
  const rubHistory = [];
  function addRubSample(dist, t){ rubHistory.push({ dist, t }); if (rubHistory.length > 18) rubHistory.shift(); }
  function computeRubIntensity(){
    if (rubHistory.length < 6) return 0;
    const D = rubHistory.map(s => s.dist);
    const T = rubHistory.map(s => s.t);
    let sumAbsDeriv = 0; const derivs = [];
    for (let i=1;i<D.length;i++){
      const dt = Math.max(1e-4, T[i] - T[i-1]);
      const deriv = (D[i] - D[i-1]) / dt;
      derivs.push(deriv); sumAbsDeriv += Math.abs(deriv);
    }
    const avgAbsDeriv = sumAbsDeriv / Math.max(1, derivs.length);
    const meanD = D.reduce((a,b)=>a+b,0)/D.length;
    let sumSq=0; for (const v of D) sumSq += (v-meanD)*(v-meanD);
    const stdDev = Math.sqrt(sumSq / D.length);
    let signChanges = 0; const magThreshold = 0.0025;
    for (let i=1;i<derivs.length;i++){
      if (Math.abs(derivs[i]) < magThreshold && Math.abs(derivs[i-1]) < magThreshold) continue;
      if (derivs[i] * derivs[i-1] < 0) signChanges++;
    }
    const latest = D[D.length - 1];
    const closeness = Math.max(0, 1 - (latest / 0.22));
    const MIN_AVG_DERIV = 0.015, MIN_STDDEV = 0.007, MIN_SIGN_CHANGES = 2;
    if (avgAbsDeriv < MIN_AVG_DERIV || stdDev < MIN_STDDEV || signChanges < MIN_SIGN_CHANGES) return 0;
    const intensity = avgAbsDeriv * 0.02 * closeness;
    return Math.max(0, Math.min(1.5, intensity));
  }
  // --------------------------------------------------------------------

  // detect fist (kept available if you want it later)
  function detectFist(hand){
    if (!hand || !hand.joints) return false;
    const wrist = getJointPositionSafe(hand, ['wrist','wrist-radius']);
    const tipNames = ['index-finger-tip','middle-finger-tip','ring-finger-tip','pinky-finger-tip'];
    const tips = [];
    for (const n of tipNames) {
      const p = getJointPositionSafe(hand, [n]);
      if (p) tips.push(p);
    }
    if (!wrist || tips.length < 3) return false;
    let sum = 0;
    for (const t of tips) sum += t.distanceTo(wrist);
    const avg = sum / tips.length;
    // spread
    let pairSum = 0, pairs = 0;
    for (let i=0;i<tips.length;i++) for (let j=i+1;j<tips.length;j++){ pairSum += tips[i].distanceTo(tips[j]); pairs++; }
    const avgPair = pairs>0 ? pairSum / pairs : 0;
    return (avg < 0.06 && avgPair < 0.07);
  }

  // orbit sphere maintain
  function maintainOrbit(dt){
    let grabbed=false; for (const v of handGrabConstraints.values()) if (v.targetBody === sphereBody) grabbed=true;
    if (grabbed) return;
    const center = centralBody.position; const orbitalRadius=2.0; const speedOrbit = 1.2;
    const t = performance.now()*0.001;
    const des = new CANNON.Vec3(center.x + Math.cos(t*speedOrbit)*orbitalRadius, 1.0 + Math.sin(t*0.5)*0.3, center.z + Math.sin(t*speedOrbit)*orbitalRadius);
    const kp=20, kd=3; const pos = sphereBody.position, vel = sphereBody.velocity;
    sphereBody.applyForce(new CANNON.Vec3((des.x-pos.x)*kp - vel.x*kd, (des.y-pos.y)*kp - vel.y*kd, (des.z-pos.z)*kp - vel.z*kd), pos);
  }

  // sync physics->graphics
  function syncPhysicsGraphics(){
    if (renderer.xr.isPresenting){
      const head = new THREE.Vector3(); camera.getWorldPosition(head);
      playerBody.position.x = head.x; playerBody.position.z = head.z;
      playerBody.position.y = Math.max(0.3, head.y - 0.55); playerBody.velocity.set(0,0,0);
    } else {
      camera.position.set(0,0.6,0);
    }
    sphereMesh.position.copy(sphereBody.position); sphereMesh.quaternion.copy(sphereBody.quaternion);
    centralMesh.position.copy(centralBody.position); centralMesh.quaternion.copy(centralBody.quaternion);
    for (let i=0;i<interactMeshes.length;i++){ interactMeshes[i].position.copy(interactBodies[i].position); interactMeshes[i].quaternion.copy(interactBodies[i].quaternion); }
    playerDebug.position.copy(playerBody.position);
  }

  // desktop pointerlock fallback
  let yaw=0, pitch=0, pointerLocked=false;
  document.addEventListener('mousemove', e => { if (!pointerLocked) return; yaw -= e.movementX*0.0025; pitch -= e.movementY*0.0025; pitch = Math.max(-Math.PI/2+0.05, Math.min(Math.PI/2-0.05, pitch)); });
  document.addEventListener('click', ()=> renderer.domElement.requestPointerLock?.());
  document.addEventListener('pointerlockchange', ()=> pointerLocked = document.pointerLockElement === renderer.domElement);

  // XR session start button
  const enterBtn = document.getElementById('enterVr');
  async function startXRWithHands(){
    if (!navigator.xr) { alert('WebXR not available'); return; }
    try {
      log('requesting immersive-vr session (hand-tracking)...');
      const session = await navigator.xr.requestSession('immersive-vr', { optionalFeatures: ['local-floor','hand-tracking','bounded-floor'] });
      log('session granted');
      await renderer.xr.setSession(session);
      // get hand references
      xrHand0 = renderer.xr.getHand(0); xrHand1 = renderer.xr.getHand(1);
      scene.add(xrHand0, xrHand1);
      // inputsourceschange â€” check for hands
      session.addEventListener('inputsourceschange', () => {
        sessionSupportsHands = Array.from(session.inputSources).some(s => !!s.hand);
        log('hand support: ' + (sessionSupportsHands ? 'yes' : 'no'));
        handGroups.forEach(h => h.group.visible = sessionSupportsHands);
      });
      sessionSupportsHands = Array.from(session.inputSources).some(s => !!s.hand);
      log('session started â€” hand support: ' + (sessionSupportsHands ? 'yes' : 'no'));
      handGroups.forEach(h => h.group.visible = sessionSupportsHands);
      enterBtn.style.display = 'none';
    } catch(err){
      console.error(err);
      log('XR session request failed â€” ' + (err && err.message ? err.message : err));
    }
  }
  enterBtn.addEventListener('click', startXRWithHands);

  // keyboard spawn fallback
  window.addEventListener('keydown', (e) => {
    if (e.code === 'KeyX') {
      const cp = new THREE.Vector3(); camera.getWorldPosition(cp); const fd = new THREE.Vector3(); camera.getWorldDirection(fd).normalize();
      spawnBox(cp.x + fd.x*1.2, cp.y + 0.4, cp.z + fd.z*1.2, 0xff88ff, 2);
    }
  });

  // main loop
  let last = null; const fixedStep = 1/60;
  function animate(ts){
    renderer.setAnimationLoop(animate);
    const t = ts ? ts/1000 : performance.now()/1000;
    if (!last) last = t;
    const dt = Math.min(1/30, t - last); last = t;

    // hands (if present)
    const hands = [xrHand0, xrHand1];
    const headPos = new THREE.Vector3(); camera.getWorldPosition(headPos);

    // collect pending grab starts so we can suppress when both triggers are held
    const pendingGrabStarts = [];

    for (let i=0;i<2;i++){
      const hand = hands[i];
      if (!hand) { handState[i].pos.set(0,0,0); continue; }
      // pinch detection
      const pin = detectPinch(hand);
      const posEstimate = pin.indexP || pin.thumbP || getJointPositionSafe(hand, ['wrist','wrist-radius']) || new THREE.Vector3();
      handState[i].prevPos.copy(handState[i].pos); handState[i].pos.copy(posEstimate);
      const dtPos = Math.max(1e-4, dt);
      handState[i].vel.copy(handState[i].pos).sub(handState[i].prevPos).divideScalar(dtPos);

      // update simple visuals
      const hv = handGroups[i];
      if (hv.group.visible) {
        const wristP = getJointPositionSafe(hand, ['wrist','wrist-radius']);
        if (wristP) hv.wrist.position.copy(wristP);
        if (pin.thumbP) hv.thumb.position.copy(pin.thumbP);
        if (pin.indexP) hv.index.position.copy(pin.indexP);
        const forward = estimateHandForward(hand);
        const muzzlePos = handState[i].pos.clone().add(forward.clone().multiplyScalar(0.06));
        hv.muzzle.position.copy(muzzlePos);
      }

      // move palm kinematic body to hand pos so it pushes objects
      const palmBody = palmBodies[i];
      if (handState[i].pos) palmBody.position.copy(new CANNON.Vec3(handState[i].pos.x, handState[i].pos.y, handState[i].pos.z));
      else palmBody.position.set(0,-100,0);

      // pinch transitions
      const now = t;
      if (pin.pinch && !handState[i].pinching) { handState[i].pinching = true; handState[i].pinchStart = now; }
      else if (!pin.pinch && handState[i].pinching) {
        const held = now - handState[i].pinchStart;
        if (held < 0.22) {
          // quick pinch -> shoot
          const muzzlePos = (handGroups[i].group.visible) ? handGroups[i].muzzle.position : handState[i].pos;
          handShoot(hand, muzzlePos);
        } else {
          // release after grab -> throw
          const throwDir = estimateHandForward(hand).clone();
          endHandGrab(i, throwDir);
        }
        handState[i].pinching = false;
      } else if (pin.pinch && handState[i].pinching) {
        const held = now - handState[i].pinchStart;
        // instead of starting grabs immediately, push to pending list; we'll decide after both-hand logic
        if (held > 0.18 && !handGrabConstraints.has(i)) {
          pendingGrabStarts.push(i);
        }
      }
    }

    // ---------- New: both-triggers-to-move ----------
    const bothPinching = handState[0].pinching && handState[1].pinching;
    const bothHeld = bothPinching && ((t - handState[0].pinchStart) > 0.15) && ((t - handState[1].pinchStart) > 0.15);
    // If both are held, we move forward (per-frame), and we suppress starting per-hand grabs
    const camF = new THREE.Vector3(); camera.getWorldDirection(camF); camF.y = 0; camF.normalize();
    if (bothHeld) {
      const nudge = 0.03; // per-frame nudge while both triggers held
      if (renderer.xr.isPresenting) {
        playerBody.position.x += camF.x * nudge;
        playerBody.position.z += camF.z * nudge;
      } else {
        playerBody.velocity.x += camF.x * nudge * 12;
        playerBody.velocity.z += camF.z * nudge * 12;
      }
    } else {
      // start pending grabs only if both-held not active
      for (const idx of pendingGrabStarts) {
        startHandGrab(idx, handState[idx].pos);
      }
    }
    // -----------------------------------------------------------------------

    // ---------- also handle rubbing movement ----------
    const leftPos = handState[0].pos.clone();
    const rightPos = handState[1].pos.clone();
    const palmDist = (leftPos && rightPos) ? leftPos.distanceTo(rightPos) : 999;
    addRubSample(palmDist, t);
    const rubIntensity = computeRubIntensity();
    const RUB_MOVE_THRESHOLD = 0.03;
    if (rubIntensity > RUB_MOVE_THRESHOLD) {
      const nudge = 0.02 * (rubIntensity * 2.5);
      if (renderer.xr.isPresenting) {
        playerBody.position.x += camF.x * nudge;
        playerBody.position.z += camF.z * nudge;
      } else {
        playerBody.velocity.x += camF.x * nudge * 12;
        playerBody.velocity.z += camF.z * nudge * 12;
      }
    }
    // ----------------------------------------------------------------------

    // update kinematic hand grabs
    updateHandKinematics();

    // orbiting sphere
    maintainOrbit(dt);

    // step physics and sync visuals
    world.step(fixedStep, dt, 4);
    syncPhysicsGraphics();

    renderer.render(scene, camera);
  }
  renderer.setAnimationLoop(animate);

  // resize handling
  window.addEventListener('resize', ()=> { camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); });

  // initial status
  log('ready â€” click "Enter VR" to start XR with hand-tracking (if supported).');

  // expose debug api
  window.spawnBox = spawnBox;
  window.playerBody = playerBody;
  window.palmBodies = palmBodies;

  </script>
</body>
</html>
