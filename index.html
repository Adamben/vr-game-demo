<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>VR Orbit - Three + cannon-es</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { margin:0; overflow:hidden; font-family: sans-serif; }
    #info {
      position: absolute; left: 10px; top: 10px; padding:8px 12px;
      background: rgba(0,0,0,0.4); color: #fff; border-radius:6px;
    }
    button { font-size: 14px; }
    canvas { display:block; }
  </style>
</head>
<body>
  <div id="info">
    VR: use your headset & thumbstick to move. Grab with controller (squeeze/select).<br>
    Desktop: WASD to move, mouse to look, E to grab nearest object, Space to jump.
  </div>

  <script type="module">
  // ---- Imports (three r128 module + VRButton) + cannon-es ----
  import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js';
  import { VRButton } from 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/webxr/VRButton.js';
  import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

  // ---- Basic three scene ----
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x101218);

  const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 1000);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(innerWidth, innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.xr.enabled = true;
  document.body.appendChild(renderer.domElement);
  document.body.appendChild(VRButton.createButton(renderer));

  // lighting
  const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
  hemi.position.set(0, 10, 0);
  scene.add(hemi);

  const dir = new THREE.DirectionalLight(0xffffff, 0.7);
  dir.position.set(5,10,7);
  dir.castShadow = true;
  dir.shadow.mapSize.set(1024,1024);
  scene.add(dir);

  // camera rig (so we can move the camera + controllers together)
  const rig = new THREE.Group();
  rig.add(camera);
  scene.add(rig);

  // ---- Cannon world ----
  const world = new CANNON.World({
    gravity: new CANNON.Vec3(0, -9.82, 0),
  });
  // Broadphase and solver tuning
  world.broadphase = new CANNON.SAPBroadphase(world);
  world.solver.iterations = 10;

  // material contact
  const defaultMat = new CANNON.Material('default');
  const contactMat = new CANNON.ContactMaterial(defaultMat, defaultMat, { friction: 0.4, restitution: 0.1 });
  world.addContactMaterial(contactMat);

  // ----- Ground -----
  const groundGeo = new THREE.PlaneGeometry(50,50);
  const groundMat = new THREE.MeshStandardMaterial({ color: 0x2a2f36 });
  const groundMesh = new THREE.Mesh(groundGeo, groundMat);
  groundMesh.rotation.x = -Math.PI/2;
  groundMesh.receiveShadow = true;
  scene.add(groundMesh);

  const groundBody = new CANNON.Body({
    type: CANNON.Body.STATIC,
    shape: new CANNON.Plane(),
    material: defaultMat
  });
  groundBody.quaternion.setFromEuler(-Math.PI/2, 0, 0);
  world.addBody(groundBody);

  // ---- central cube (static) ----
  const centralGeo = new THREE.BoxGeometry(1,1,1);
  const centralMat = new THREE.MeshStandardMaterial({ color: 0xff0000 });
  const centralMesh = new THREE.Mesh(centralGeo, centralMat);
  centralMesh.castShadow = true;
  centralMesh.position.set(0,0.5,0);
  scene.add(centralMesh);

  // central cube physics (static)
  const centralBody = new CANNON.Body({
    type: CANNON.Body.STATIC,
    shape: new CANNON.Box(new CANNON.Vec3(0.5,0.5,0.5)),
    position: new CANNON.Vec3(0,0.5,0),
    material: defaultMat
  });
  world.addBody(centralBody);

  // ---- orbiting sphere (dynamic, but we'll apply a motorized orbit force) ----
  const sphereGeo = new THREE.SphereGeometry(0.4, 32, 32);
  const sphereMat = new THREE.MeshStandardMaterial({ color: 0x00ff00, metalness:0.2, roughness:0.6 });
  const sphereMesh = new THREE.Mesh(sphereGeo, sphereMat);
  sphereMesh.castShadow = true;
  scene.add(sphereMesh);

  const sphereBody = new CANNON.Body({
    mass: 1,
    shape: new CANNON.Sphere(0.4),
    position: new CANNON.Vec3(2, 1, 0),
    material: defaultMat
  });
  world.addBody(sphereBody);

  // ---- extra boxes to interact with ----
  const interactMeshes = [];
  const interactBodies = [];
  function spawnBox(x,y,z,color=0x3377ff) {
    const geo = new THREE.BoxGeometry(0.6,0.6,0.6);
    const mat = new THREE.MeshStandardMaterial({ color });
    const m = new THREE.Mesh(geo, mat);
    m.castShadow = true;
    m.position.set(x,y,z);
    scene.add(m);
    interactMeshes.push(m);

    const b = new CANNON.Body({
      mass: 2,
      shape: new CANNON.Box(new CANNON.Vec3(0.3,0.3,0.3)),
      position: new CANNON.Vec3(x,y,z),
      material: defaultMat
    });
    world.addBody(b);
    interactBodies.push(b);
    return { m, b };
  }

  spawnBox(1.5, 1, -1, 0x4488ff);
  spawnBox(-1.5, 1, -1, 0xffaa33);
  spawnBox(0, 2, -2, 0x00ffaa);

  // ---- Player collider/body (simple sphere) ----
  const playerBody = new CANNON.Body({
    mass: 1,
    shape: new CANNON.Sphere(0.35),
    position: new CANNON.Vec3(0, 1.0, 5),
    fixedRotation: true,
    material: defaultMat
  });
  // allow sliding
  playerBody.linearDamping = 0.9;
  world.addBody(playerBody);

  // small invisible mesh to help debug (optional)
  const playerDebug = new THREE.Mesh(
    new THREE.SphereGeometry(0.35, 8, 8),
    new THREE.MeshBasicMaterial({ visible:false })
  );
  scene.add(playerDebug);

  // attach camera to player: camera offset
  const cameraHeight = 0.6; // where camera sits relative to player body center

  // ---- Simple player movement state ----
  const moveState = { forward:0, right:0, jump:false };
  const speed = 3.0;
  let canJump = false;

  // keyboard controls (desktop fallback)
  const keys = {};
  window.addEventListener('keydown', (e) => {
    keys[e.code] = true;
    if (e.code === 'KeyW') moveState.forward = 1;
    if (e.code === 'KeyS') moveState.forward = -1;
    if (e.code === 'KeyA') moveState.right = -1;
    if (e.code === 'KeyD') moveState.right = 1;
    if (e.code === 'Space') moveState.jump = true;
    if (e.code === 'KeyE') tryGrabNearest(); // desktop grab
  });
  window.addEventListener('keyup', (e) => {
    keys[e.code] = false;
    if (!keys['KeyW'] && !keys['KeyS']) moveState.forward = 0;
    if (!keys['KeyA'] && !keys['KeyD']) moveState.right = 0;
    if (e.code === 'Space') moveState.jump = false;
  });

  // ---- Mouse look for non-VR mode ----
  let yaw = 0, pitch = 0;
  let pointerLocked = false;
  function pointerMove(e){
    if (!pointerLocked) return;
    const sensitivity = 0.002;
    yaw -= e.movementX * sensitivity;
    pitch -= e.movementY * sensitivity;
    pitch = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, pitch));
  }
  document.addEventListener('mousemove', pointerMove);
  document.addEventListener('click', () => {
    if (!navigator.xr) {
      // request pointer lock on desktop to fly/look
      renderer.domElement.requestPointerLock?.();
    }
  });
  document.addEventListener('pointerlockchange', () => {
    pointerLocked = document.pointerLockElement === renderer.domElement;
  });

  // ---- VR controllers ----
  const controller1 = renderer.xr.getController(0);
  const controller2 = renderer.xr.getController(1);
  scene.add(controller1);
  scene.add(controller2);

  // add ray visuals for controllers
  function makeControllerMesh() {
    const g = new THREE.CylinderGeometry(0.01, 0.02, 0.15, 8);
    const m = new THREE.Mesh(g, new THREE.MeshNormalMaterial());
    m.rotation.x = -Math.PI/2;
    return m;
  }
  controller1.add(makeControllerMesh());
  controller2.add(makeControllerMesh());

  // track active grab constraints
  const grabConstraints = new Map(); // controller -> { constraint, body }

  // helper: raycast from controller to find nearest dynamic body
  function controllerRaycast(controller) {
    const tempMatrix = new THREE.Matrix4();
    tempMatrix.identity().extractRotation(controller.matrixWorld);

    const origin = new THREE.Vector3();
    controller.getWorldPosition(origin);

    const direction = new THREE.Vector3(0,0,-1).applyMatrix4(tempMatrix).normalize();

    // simple intersection: test distance to bounding spheres of dynamic bodies
    let best = null;
    let bestDist = 999;
    const maxDist = 2.5;
    for (let b of [sphereBody, ...interactBodies]) {
      if (b.type === CANNON.Body.STATIC) continue;
      const pos = new THREE.Vector3(b.position.x, b.position.y, b.position.z);
      const to = pos.clone().sub(origin);
      const proj = to.dot(direction);
      if (proj < 0 || proj > maxDist) continue;
      const perpDist = to.clone().sub(direction.clone().multiplyScalar(proj)).length();
      const radius = b.shapes[0] instanceof CANNON.Sphere ? b.shapes[0].radius : 0.5;
      if (perpDist <= radius + 0.15) {
        if (proj < bestDist) { bestDist = proj; best = { body: b, hitPoint: origin.clone().add(direction.clone().multiplyScalar(proj)) }; }
      }
    }
    return best;
  }

  // on selectstart, try to grab object
  function onSelectStart() {
    const controller = this;
    const hit = controllerRaycast(controller);
    if (!hit) return;
    const body = hit.body;

    // convert hitPoint to local world vector for cannon pivot
    const pivot = new CANNON.Vec3().copy(hit.hitPoint);
    // create a new body for the controller (kinematic) and a PointToPointConstraint
    // Instead of creating another body, we'll use a kinematic body representing controller position
    const ctrlBody = new CANNON.Body({ mass: 0 }); // kinematic / static
    ctrlBody.type = CANNON.Body.KINEMATIC;
    ctrlBody.position.copy(new CANNON.Vec3().copy(controller.position).vadd(new CANNON.Vec3(0,0,0)));
    world.addBody(ctrlBody);

    const constraint = new CANNON.PointToPointConstraint(body, body.pointToLocalFrame(pivot), ctrlBody, new CANNON.Vec3(0,0,0));
    world.addConstraint(constraint);

    grabConstraints.set(controller, { constraint, ctrlBody, targetBody: body });
  }

  function onSelectEnd() {
    const controller = this;
    const data = grabConstraints.get(controller);
    if (!data) return;
    // apply throw impulse based on controller velocity
    // approximate controller linear velocity by tracking recent positions (simple)
    // For simplicity, apply a small impulse outward
    const impulse = new CANNON.Vec3();
    // get controller forward
    const forward = new THREE.Vector3(0,0,-1).applyQuaternion(controller.quaternion);
    impulse.set(forward.x, forward.y, forward.z).scale(2.5);
    data.targetBody.applyImpulse(impulse, data.targetBody.position);

    world.removeConstraint(data.constraint);
    world.removeBody(data.ctrlBody);
    grabConstraints.delete(controller);
  }

  // wire events
  controller1.addEventListener('selectstart', onSelectStart);
  controller1.addEventListener('selectend', onSelectEnd);
  controller2.addEventListener('selectstart', onSelectStart);
  controller2.addEventListener('selectend', onSelectEnd);

  // we also allow "squeezestart"/"squeezeend" as alternates
  controller1.addEventListener('squeezestart', onSelectStart);
  controller1.addEventListener('squeezeend', onSelectEnd);
  controller2.addEventListener('squeezestart', onSelectStart);
  controller2.addEventListener('squeezeend', onSelectEnd);

  // ---- Utility: find nearest interactable and grab (desktop E) ----
  function tryGrabNearest() {
    // pick the nearest dynamic body to player within 2m
    let best = null; let bd = 999;
    for (let b of [sphereBody, ...interactBodies]) {
      const d = playerBody.position.distanceTo(b.position);
      if (d < 2 && d < bd) { bd = d; best = b; }
    }
    if (!best) return;
    // create a fixed constraint from player to object (simulate hold)
    const ctrlBody = new CANNON.Body({ mass:0, type: CANNON.Body.KINEMATIC });
    ctrlBody.position.copy(playerBody.position.vadd(new CANNON.Vec3(0,0.6, -0.7))); // in front of player
    world.addBody(ctrlBody);
    const constraint = new CANNON.PointToPointConstraint(best, best.pointToLocalFrame(ctrlBody.position), ctrlBody, new CANNON.Vec3(0,0,0));
    world.addConstraint(constraint);
    // auto-release after 1.2s for desktop convenience
    setTimeout(()=> {
      world.removeConstraint(constraint);
      world.removeBody(ctrlBody);
    }, 1200);
  }

  // ---- Animation / simulation loop ----
  let lastTime;
  const timeStep = 1/60;

  // For controller kinematic bodies: update their position each frame from controller world positions
  function updateControllerBodies() {
    for (const [controller, data] of grabConstraints) {
      if (!data) continue;
      // get controller world pos
      const pos = new THREE.Vector3();
      controller.getWorldPosition(pos);
      data.ctrlBody.position.copy(new CANNON.Vec3(pos.x, pos.y, pos.z));
      // also set quaternion for orientation if needed (not necessary for point-to-point)
      const quat = new THREE.Quaternion();
      controller.getWorldQuaternion(quat);
      data.ctrlBody.quaternion.copy(new CANNON.Quaternion(quat.x, quat.y, quat.z, quat.w));
    }
  }

  // helper to sync three meshes with cannon bodies
  function syncPhysicsToGraphics() {
    // player camera: set rig position to playerBody and offset camera up
    rig.position.set(playerBody.position.x, playerBody.position.y + cameraHeight, playerBody.position.z);

    // sphere
    sphereMesh.position.copy(sphereBody.position);
    sphereMesh.quaternion.copy(sphereBody.quaternion);

    // central cube and its body handled rarely but keep synced (static)
    centralMesh.position.copy(centralBody.position);
    centralMesh.quaternion.copy(centralBody.quaternion);

    // interactables
    for (let i=0;i<interactMeshes.length;i++){
      interactMeshes[i].position.copy(interactBodies[i].position);
      interactMeshes[i].quaternion.copy(interactBodies[i].quaternion);
    }
    // debug player (invisible)
    playerDebug.position.copy(playerBody.position);
  }

  // Function to process VR thumbstick movement for each controller
  function processVRInput() {
    // for each controller, check gamepad axes
    const session = renderer.xr.getSession && renderer.xr.getSession();
    let forward = 0, right = 0;
    // gather axes from both controllers (some headsets put primary thumbstick on controller[0])
    [controller1, controller2].forEach(controller => {
      const gp = controller.gamepad;
      if (!gp) return;
      // standard mapping uses gp.axes[2] and [3] for secondary stick; some devices use 0/1
      // we'll check both common locations
      const axX = (gp.axes.length > 2 ? gp.axes[2] : gp.axes[0]) || 0;
      const axY = (gp.axes.length > 3 ? gp.axes[3] : gp.axes[1]) || 0;
      // forward is -Y
      forward += -axY;
      right += axX;
    });
    // normalize
    forward = Math.max(-1, Math.min(1, forward));
    right = Math.max(-1, Math.min(1, right));
    return { forward, right };
  }

  // apply a simple orbit force to the sphere to keep it orbiting the central cube unless grabbed
  function maintainOrbit(dt) {
    if (sphereBody.sleepState === CANNON.Body.SLEEPING) return;
    // if it's being grabbed (massively constrained), skip
    let grabbed = false;
    for (const g of grabConstraints.values()) if (g.targetBody === sphereBody) grabbed = true;
    if (grabbed) return;

    const center = centralBody.position;
    const orbitalRadius = 2.0;
    const speed = 1.2; // radians/s

    // compute desired position on a circle that moves in time
    const t = performance.now() * 0.001;
    const desiredX = center.x + Math.cos(t * speed) * orbitalRadius;
    const desiredZ = center.z + Math.sin(t * speed) * orbitalRadius;
    const desiredY = 1.0 + Math.sin(t * 0.5) * 0.3;

    // simple PD-like spring to pull the sphere towards desired position
    const kp = 20;
    const kd = 3;
    const pos = sphereBody.position;
    const vel = sphereBody.velocity;

    const force = new CANNON.Vec3(
      (desiredX - pos.x) * kp - vel.x * kd,
      (desiredY - pos.y) * kp - vel.y * kd,
      (desiredZ - pos.z) * kp - vel.z * kd
    );
    sphereBody.applyForce(force, pos);
  }

  // Detect when player is on ground (for jumping)
  world.addEventListener('postStep', () => {
    canJump = false;
    // raycast a little down from player
    const from = playerBody.position.clone();
    const to = playerBody.position.clone().vsub(new CANNON.Vec3(0,0.7,0));
    const result = new CANNON.RaycastResult();
    const ray = new CANNON.Ray(from, to);
    ray.intersectWorld(world, { collisionFilterMask: -1, skipBackfaces: true }, result);
    if (result.hasHit) canJump = true;
  });

  // Main loop
  function animate(timestamp) {
    renderer.setAnimationLoop(animate); // ensure XR uses this loop
    const time = timestamp ? timestamp / 1000 : performance.now() / 1000;
    if (!lastTime) lastTime = time;
    let dt = Math.min(1/30, time - lastTime);
    lastTime = time;

    // VR input or desktop WASD
    let moveForward = moveState.forward;
    let moveRight = moveState.right;

    if (renderer.xr.isPresenting) {
      const vrAxes = processVRInput();
      // small deadzone
      if (Math.abs(vrAxes.forward) > 0.12) moveForward = vrAxes.forward;
      if (Math.abs(vrAxes.right) > 0.12) moveRight = vrAxes.right;
    } else {
      // apply desktop mouse rotation to yaw/pitch
    }

    // compute direction relative to camera (yaw)
    const euler = new THREE.Euler(pitch, yaw, 0, 'YXZ');
    const forwardVec = new THREE.Vector3(0,0,-1).applyEuler(euler).setY(0).normalize();
    const rightVec = new THREE.Vector3(1,0,0).applyEuler(euler).setY(0).normalize();

    // apply velocity to player body
    const targetVel = new CANNON.Vec3(
      (forwardVec.x * moveForward + rightVec.x * moveRight) * speed,
      playerBody.velocity.y,
      (forwardVec.z * moveForward + rightVec.z * moveRight) * speed
    );
    // smoothing: lerp current velocity to target
    const lerpFactor = 0.2;
    playerBody.velocity.x += (targetVel.x - playerBody.velocity.x) * lerpFactor;
    playerBody.velocity.z += (targetVel.z - playerBody.velocity.z) * lerpFactor;

    // jump
    if (moveState.jump && canJump) {
      playerBody.velocity.y = 5.2;
      moveState.jump = false;
    }

    // update any controller kinematic bodies
    updateControllerBodies();

    // orbit sphere
    maintainOrbit(dt);

    // step physics
    world.step(timeStep, dt, 3);

    // sync graphics
    syncPhysicsToGraphics();

    // update camera orientation for desktop
    if (!renderer.xr.isPresenting) {
      camera.quaternion.setFromEuler(new THREE.Euler(pitch, yaw, 0, 'YXZ'));
    } else {
      // when in XR, rig's position is set from playerBody; camera comes from XR pose
    }

    renderer.render(scene, camera);
  }

  // start loop (non-XR path)
  renderer.setAnimationLoop(animate);

  // ---- window resize ----
  window.addEventListener('resize', () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });

  // ---- Make scene slightly prettier: skybox-ish gradient ----
  const boxGeo = new THREE.BoxGeometry(100,100,100);
  const boxMat = new THREE.MeshBasicMaterial({ color: 0x081018, side: THREE.BackSide });
  const boxMesh = new THREE.Mesh(boxGeo, boxMat);
  scene.add(boxMesh);

  // ---- keep three/cannon in sync on start ----
  syncPhysicsToGraphics();

  // ---- helpful: expose spawn for dev console ----
  window.spawnBox = spawnBox;

  // ---- Done ----
  console.log('VR Orbit demo loaded. Use WASD or VR controllers. spawnBox(x,y,z) available from console.');
  </script>
</body>
</html>
