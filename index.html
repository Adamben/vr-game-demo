<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Hand-only VR — Hand-mounted Blasters + Rubbing Walk (Default On)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { margin:0; overflow:hidden; font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif; }
    #info {
      position: absolute; left: 10px; top: 10px; padding:10px 14px; background: rgba(0,0,0,0.45);
      color: #fff; border-radius:8px; max-width:380px; line-height:1.2;
    }
    #info b { color:#ffd; }
  </style>
</head>
<body>
  <div id="info">
    <b>Hand-tracking: ON</b> — Pinch (thumb+index) to shoot from the <b>hand-mounted blasters</b>. <br>
    Rub hands together to move forward. <br>
    Desktop fallback: click to lock pointer, WASD to move, X to spawn a block.
  </div>

  <script type="module">
  import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js';
  import { VRButton } from 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/webxr/VRButton.js';
  import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

  // --- three + renderer ---
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x081018);
  const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.05, 1000);
  const renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setSize(innerWidth, innerHeight);
  renderer.xr.enabled = true;
  renderer.shadowMap.enabled = true;
  document.body.appendChild(renderer.domElement);
  document.body.appendChild(VRButton.createButton(renderer));

  // lighting
  const hemi = new THREE.HemisphereLight(0xffffff, 0x222244, 0.8); hemi.position.set(0,10,0); scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 0.6); dir.position.set(3,10,6); dir.castShadow = true; scene.add(dir);

  // rig & camera
  const rig = new THREE.Group();
  rig.add(camera);
  scene.add(rig);

  // --- cannon world ---
  const world = new CANNON.World({ gravity: new CANNON.Vec3(0,-9.82,0) });
  world.broadphase = new CANNON.SAPBroadphase(world);
  world.solver.iterations = 10;
  const defaultMat = new CANNON.Material('default');
  world.addContactMaterial(new CANNON.ContactMaterial(defaultMat, defaultMat, { friction:0.5, restitution:0.05 }));

  // ground
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(120,120), new THREE.MeshStandardMaterial({ color:0x263238 }));
  ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);
  const groundBody = new CANNON.Body({ type: CANNON.Body.STATIC, shape: new CANNON.Plane(), material: defaultMat });
  groundBody.quaternion.setFromEuler(-Math.PI/2,0,0); world.addBody(groundBody);

  // central cube + orbit sphere
  const centralMesh = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshStandardMaterial({ color:0xff4444 }));
  centralMesh.position.set(0,0.5,0); centralMesh.castShadow = true; scene.add(centralMesh);
  const centralBody = new CANNON.Body({ type: CANNON.Body.STATIC, shape: new CANNON.Box(new CANNON.Vec3(0.5,0.5,0.5)), position: new CANNON.Vec3(0,0.5,0), material: defaultMat });
  world.addBody(centralBody);

  const sphereMesh = new THREE.Mesh(new THREE.SphereGeometry(0.4,32,32), new THREE.MeshStandardMaterial({ color:0x00ff88 }));
  sphereMesh.castShadow = true; scene.add(sphereMesh);
  const sphereBody = new CANNON.Body({ mass:1, shape: new CANNON.Sphere(0.4), position: new CANNON.Vec3(2,1,0), material: defaultMat });
  world.addBody(sphereBody);

  // interactable lists
  const interactMeshes = [];
  const interactBodies = [];
  function spawnBox(x,y,z,color=0x4488ff,mass=2){
    const m = new THREE.Mesh(new THREE.BoxGeometry(0.6,0.6,0.6), new THREE.MeshStandardMaterial({ color }));
    m.castShadow=true; m.position.set(x,y,z); scene.add(m);
    const b = new CANNON.Body({ mass, shape: new CANNON.Box(new CANNON.Vec3(0.3,0.3,0.3)), position:new CANNON.Vec3(x,y,z), material: defaultMat });
    world.addBody(b);
    interactMeshes.push(m); interactBodies.push(b);
    return { m,b };
  }

  // two static blocks (mass = 0 => static)
  spawnBox(-3,0.375,-1.5,0x4455aa,0);
  spawnBox(3,0.6,-2,0xaa5544,0);

  // initial interactables
  spawnBox(1.5,1,-1,0x4488ff,2);
  spawnBox(-1.5,1,-1,0xffaa33,2);
  spawnBox(0,2,-2,0x00ffaa,2);

  // player physics body to push objects
  const playerBody = new CANNON.Body({ mass:1, shape: new CANNON.Sphere(0.35), position: new CANNON.Vec3(0,1.0,4), fixedRotation:true, material: defaultMat });
  playerBody.linearDamping = 0.9; world.addBody(playerBody);

  // helper debug (invisible)
  const playerDebug = new THREE.Mesh(new THREE.SphereGeometry(0.35,8,8), new THREE.MeshBasicMaterial({ visible:false }));
  scene.add(playerDebug);

  // movement variables
  const speed = 3.0;
  let canJump = false;
  const moveState = { forward:0, right:0, jump:false };

  // desktop fallback controls
  const keys = {};
  window.addEventListener('keydown', e => {
    keys[e.code] = true;
    if (e.code === 'KeyW') moveState.forward = 1;
    if (e.code === 'KeyS') moveState.forward = -1;
    if (e.code === 'KeyA') moveState.right = -1;
    if (e.code === 'KeyD') moveState.right = 1;
    if (e.code === 'Space') moveState.jump = true;
    if (e.code === 'KeyX') { const cp = new THREE.Vector3(); camera.getWorldPosition(cp); const dir = new THREE.Vector3(); camera.getWorldDirection(dir); spawnBox(cp.x + dir.x*1.2, cp.y + 0.4, cp.z + dir.z*1.2, 0xff88ff, 2); }
  });
  window.addEventListener('keyup', e => {
    keys[e.code] = false;
    if (!keys['KeyW'] && !keys['KeyS']) moveState.forward = 0;
    if (!keys['KeyA'] && !keys['KeyD']) moveState.right = 0;
    if (e.code === 'Space') moveState.jump = false;
  });
  document.addEventListener('click', ()=> renderer.domElement.requestPointerLock?.());

  // --- HAND-ONLY setup (default ON) ---
  const xrHand0 = renderer.xr.getHand(0);
  const xrHand1 = renderer.xr.getHand(1);
  scene.add(xrHand0, xrHand1);

  // hand visual groups (spheres to show wrist/thumb/index and muzzle)
  function makeHandVisualGroup(color) {
    const g = new THREE.Group();
    const wrist = new THREE.Mesh(new THREE.SphereGeometry(0.04,8,8), new THREE.MeshStandardMaterial({ color }));
    const thumb = new THREE.Mesh(new THREE.SphereGeometry(0.03,8,8), new THREE.MeshStandardMaterial({ color:0xffeebb }));
    const index = new THREE.Mesh(new THREE.SphereGeometry(0.03,8,8), new THREE.MeshStandardMaterial({ color:0xccffcc }));
    const muzzle = new THREE.Mesh(new THREE.SphereGeometry(0.04,12,12), new THREE.MeshStandardMaterial({ color:0xffdd66 }));
    muzzle.visible = true;
    g.add(wrist, thumb, index, muzzle);
    return { group: g, wrist, thumb, index, muzzle };
  }

  const hand0Vis = makeHandVisualGroup(0xff9966);
  const hand1Vis = makeHandVisualGroup(0x66ccff);
  scene.add(hand0Vis.group, hand1Vis.group);

  // hide controllers if present (we only use hands)
  const controllerA = renderer.xr.getController(0);
  const controllerB = renderer.xr.getController(1);
  controllerA.visible = controllerB.visible = false;

  // track hand state history for pinch & rubbing
  const handState = [
    { pinch:false, pinchStart:0, pos: new THREE.Vector3(), prevPos: new THREE.Vector3(), vel: new THREE.Vector3(), distToHead:0 },
    { pinch:false, pinchStart:0, pos: new THREE.Vector3(), prevPos: new THREE.Vector3(), vel: new THREE.Vector3(), distToHead:0 }
  ];

  // helper: get joint world position safely
  function getJointPosition(hand, jointNames) {
    if (!hand || !hand.joints) return null;
    for (const n of jointNames) {
      try {
        const j = hand.joints[n];
        if (j && j.visible && j.matrixWorld) {
          return new THREE.Vector3().setFromMatrixPosition(j.matrixWorld);
        }
      } catch(e){}
    }
    // fallback to hand group position
    const tmp = new THREE.Vector3(); hand.getWorldPosition(tmp); return tmp;
  }

  // detectPinch returns pinch bool and joint positions
  function detectPinch(hand) {
    const thumbNames = ['thumb-tip','thumb-tip','thumb-phalanx-tip'];
    const indexNames = ['index-finger-tip','index-tip','index-finger-phalanx-tip'];
    const thumbP = getJointPosition(hand, thumbNames);
    const indexP = getJointPosition(hand, indexNames);
    if (!thumbP || !indexP) return { pinch: false, thumbP, indexP, distance: 999 };
    const d = thumbP.distanceTo(indexP);
    return { pinch: d < 0.045, thumbP, indexP, distance: d };
  }

  // Raycast bodies helper
  function raycastBodies(origin, direction, maxDist=30) {
    let best = null; let bestDist = Infinity;
    for (const b of [sphereBody, ...interactBodies]) {
      if (b.type === CANNON.Body.STATIC) continue;
      const pos = new THREE.Vector3(b.position.x, b.position.y, b.position.z);
      const to = pos.clone().sub(origin);
      const proj = to.dot(direction);
      if (proj < 0 || proj > maxDist) continue;
      const perp = to.clone().sub(direction.clone().multiplyScalar(proj)).length();
      const radius = (b.shapes[0] instanceof CANNON.Sphere) ? b.shapes[0].radius : 0.35;
      if (perp <= radius + 0.12 && proj < bestDist) { bestDist = proj; best = { body: b, hitPoint: origin.clone().add(direction.clone().multiplyScalar(proj)), dist: proj }; }
    }
    return best;
  }

  // Estimate hand forward using wrist->indexTip (preferred) or indexTip - thumb as fallback
  function estimateHandForward(hand) {
    // try wrist and index tip
    const wrist = getJointPosition(hand, ['wrist','wrist-radius','wrist']);
    const indexTip = getJointPosition(hand, ['index-finger-tip','index-tip','index-finger-phalanx-tip']);
    const thumbTip = getJointPosition(hand, ['thumb-tip','thumb-phalanx-tip']);
    const dir = new THREE.Vector3();
    if (wrist && indexTip) {
      dir.copy(indexTip).sub(wrist).normalize();
    } else if (indexTip && thumbTip) {
      dir.copy(indexTip).sub(thumbTip).normalize();
    } else {
      camera.getWorldDirection(dir);
    }
    // keep low y bias (so shots mostly horizontal)
    if (Math.abs(dir.y) > 0.85) { dir.y *= 0.5; dir.normalize(); }
    return dir;
  }

  // shoot from a given hand: origin = muzzle pos, direction = estimated hand forward
  function handShoot(hand, muzzlePos) {
    const dir = estimateHandForward(hand);
    if (dir.length() < 1e-4) { camera.getWorldDirection(dir); dir.y *= 0.1; dir.normalize(); }
    const origin = muzzlePos.clone();
    const hit = raycastBodies(origin, dir, 40);
    if (hit) {
      const impulse = new CANNON.Vec3(dir.x, dir.y, dir.z).scale(8);
      hit.body.applyImpulse(impulse, hit.body.position);
    } else {
      // spawn projectile from hand muzzle
      const pGeo = new THREE.SphereGeometry(0.05,8,8);
      const pMat = new THREE.MeshStandardMaterial({ color:0xffdd66 });
      const pMesh = new THREE.Mesh(pGeo, pMat); pMesh.castShadow = true; scene.add(pMesh);
      const spawn = origin.clone().add(dir.clone().multiplyScalar(0.08));
      pMesh.position.copy(spawn);
      const pBody = new CANNON.Body({ mass:0.18, shape: new CANNON.Sphere(0.05), position: new CANNON.Vec3(spawn.x, spawn.y, spawn.z), material: defaultMat });
      pBody.velocity.set(dir.x*24, dir.y*24, dir.z*24);
      world.addBody(pBody);
      interactMeshes.push(pMesh); interactBodies.push(pBody);
      setTimeout(()=> { try { scene.remove(pMesh); world.removeBody(pBody); } catch(e){} }, 6000);
    }
  }

  // grabbing via sustained pinch -> point-to-point constraint
  const handGrabConstraints = new Map(); // index -> { constraint, ctrlBody, targetBody }

  function startHandGrab(index, pos) {
    if (handGrabConstraints.has(index)) return;
    // find nearby body within 0.28 m
    let best=null, bd=999;
    for (const b of [sphereBody, ...interactBodies]) {
      const d = pos.distanceTo(new THREE.Vector3(b.position.x,b.position.y,b.position.z));
      if (d < 0.28 && d < bd) { bd = d; best = b; }
    }
    if (!best) return;
    const ctrl = new CANNON.Body({ mass:0, type: CANNON.Body.KINEMATIC });
    ctrl.position.copy(new CANNON.Vec3(pos.x, pos.y, pos.z));
    world.addBody(ctrl);
    const pivot = best.pointToLocalFrame(new CANNON.Vec3(pos.x, pos.y, pos.z));
    const constraint = new CANNON.PointToPointConstraint(best, pivot, ctrl, new CANNON.Vec3(0,0,0));
    world.addConstraint(constraint);
    handGrabConstraints.set(index, { constraint, ctrlBody: ctrl, targetBody: best });
  }

  function endHandGrab(index, throwDir=null) {
    const data = handGrabConstraints.get(index);
    if (!data) return;
    if (throwDir) {
      data.targetBody.applyImpulse(new CANNON.Vec3(throwDir.x, throwDir.y, throwDir.z).scale(2.5), data.targetBody.position);
    }
    try { world.removeConstraint(data.constraint); world.removeBody(data.ctrlBody); } catch(e){}
    handGrabConstraints.delete(index);
  }

  // update kinematic hand controllers following hand positions
  function updateHandKinematics() {
    for (const [idx, data] of handGrabConstraints) {
      const p = handState[idx].pos;
      data.ctrlBody.position.copy(new CANNON.Vec3(p.x, p.y, p.z));
    }
  }

  // rubbing detection history
  const rubHistory = [];
  function addRubSample(dist, t) {
    rubHistory.push({ dist, t });
    if (rubHistory.length > 14) rubHistory.shift();
  }
  function computeRubIntensity() {
    if (rubHistory.length < 6) return 0;
    let sumAbsDeriv = 0;
    for (let i=1;i<rubHistory.length;i++){
      const dt = Math.max(1e-4, rubHistory[i].t - rubHistory[i-1].t);
      sumAbsDeriv += Math.abs((rubHistory[i].dist - rubHistory[i-1].dist)/dt);
    }
    const avgDeriv = sumAbsDeriv / (rubHistory.length - 1);
    const latest = rubHistory[rubHistory.length -1].dist;
    const closeness = Math.max(0, 1 - (latest / 0.22));
    const intensity = avgDeriv * 0.02 * closeness;
    return Math.max(0, Math.min(1.5, intensity));
  }

  // orbit maintain for sphere
  function maintainOrbit(dt) {
    let grabbed = false; for (const v of handGrabConstraints.values()) if (v.targetBody === sphereBody) grabbed = true;
    if (grabbed) return;
    const center = centralBody.position; const orbitalRadius = 2.0; const speedOrbit = 1.2;
    const t = performance.now()*0.001;
    const des = new CANNON.Vec3(center.x + Math.cos(t*speedOrbit)*orbitalRadius, 1.0 + Math.sin(t*0.5)*0.3, center.z + Math.sin(t*speedOrbit)*orbitalRadius);
    const kp=20, kd=3;
    const pos = sphereBody.position, vel = sphereBody.velocity;
    sphereBody.applyForce(new CANNON.Vec3((des.x-pos.x)*kp - vel.x*kd, (des.y-pos.y)*kp - vel.y*kd, (des.z-pos.z)*kp - vel.z*kd), pos);
  }

  // cannon ground detection for jump
  world.addEventListener('postStep', ()=> {
    canJump = false;
    const from = playerBody.position.clone();
    const to = playerBody.position.clone().vsub(new CANNON.Vec3(0,0.8,0));
    const ray = new CANNON.Ray(from,to);
    const res = new CANNON.RaycastResult();
    ray.intersectWorld(world, { skipBackfaces:true }, res);
    if (res.hasHit) canJump = true;
  });

  // sync physics -> graphics
  function syncPhysicsGraphics() {
    if (renderer.xr.isPresenting) {
      const head = new THREE.Vector3(); camera.getWorldPosition(head);
      playerBody.position.x = head.x; playerBody.position.z = head.z;
      playerBody.position.y = Math.max(0.3, head.y - 0.55);
      playerBody.velocity.set(0,0,0);
    } else {
      rig.position.set(playerBody.position.x, playerBody.position.y + 0.0, playerBody.position.z);
      camera.position.set(0,0.6,0);
    }
    sphereMesh.position.copy(sphereBody.position); sphereMesh.quaternion.copy(sphereBody.quaternion);
    centralMesh.position.copy(centralBody.position); centralMesh.quaternion.copy(centralBody.quaternion);
    for (let i=0;i<interactMeshes.length;i++){ interactMeshes[i].position.copy(interactBodies[i].position); interactMeshes[i].quaternion.copy(interactBodies[i].quaternion); }
    playerDebug.position.copy(playerBody.position);
  }

  // desktop camera orientation compute
  let yaw=0, pitch=0, pointerLocked=false;
  document.addEventListener('mousemove', e => { if (!pointerLocked) return; yaw -= e.movementX*0.0025; pitch -= e.movementY*0.0025; pitch = Math.max(-Math.PI/2+0.05, Math.min(Math.PI/2-0.05, pitch)); });
  document.addEventListener('click', ()=> renderer.domElement.requestPointerLock?.());
  document.addEventListener('pointerlockchange', ()=> pointerLocked = document.pointerLockElement === renderer.domElement);

  // MAIN LOOP
  let last = null; const fixedStep = 1/60;
  function animate(time) {
    renderer.setAnimationLoop(animate);
    const t = time ? time/1000 : performance.now()/1000;
    if (!last) last = t;
    const dt = Math.min(1/30, t - last);
    last = t;

    // Update hand states & visuals
    const hands = [xrHand0, xrHand1];
    const headPos = new THREE.Vector3(); camera.getWorldPosition(headPos);

    for (let i=0;i<2;i++){
      const hand = hands[i];
      const pin = detectPinch(hand);
      // choose a reliable pos for the hand: prefer index tip, then thumb tip, then wristfallback
      const posEstimate = pin.indexP || pin.thumbP || getJointPosition(hand, ['wrist','wrist']);
      if (!posEstimate) posEstimate = new THREE.Vector3();
      handState[i].prevPos.copy(handState[i].pos);
      handState[i].pos.copy(posEstimate);
      const dtPos = Math.max(1e-4, dt);
      handState[i].vel.copy(handState[i].pos).sub(handState[i].prevPos).divideScalar(dtPos);
      handState[i].distToHead = handState[i].pos.distanceTo(headPos);

      // update visuals
      const hv = (i===0) ? hand0Vis : hand1Vis;
      hv.group.visible = true; // hand-tracking default ON
      // place wrist/index/thumb if available
      const wristPos = getJointPosition(hand, ['wrist','wrist-radius']);
      if (wristPos) hv.wrist.position.copy(wristPos);
      if (pin.thumbP) hv.thumb.position.copy(pin.thumbP);
      if (pin.indexP) hv.index.position.copy(pin.indexP);

      // place muzzle slightly forward along estimated forward
      const forward = estimateHandForward(hand);
      const muzzlePos = handState[i].pos.clone().add(forward.clone().multiplyScalar(0.06));
      hv.muzzle.position.copy(muzzlePos);

      // pinch state transitions
      const now = t;
      if (pin.pinch && !handState[i].pinch) {
        handState[i].pinch = true; handState[i].pinchStart = now;
      } else if (!pin.pinch && handState[i].pinch) {
        const held = now - handState[i].pinchStart;
        if (held < 0.22) {
          // quick pinch -> shot from hand muzzle
          handShoot(hand, hv.muzzle.position);
        } else {
          // sustained pinch release -> throw if grabbed
          const throwDir = estimateHandForward(hand).clone();
          endHandGrab(i, throwDir);
        }
        handState[i].pinch = false;
      } else if (pin.pinch && handState[i].pinch) {
        const held = now - handState[i].pinchStart;
        if (held > 0.18 && !handGrabConstraints.has(i)) {
          // start grab
          startHandGrab(i, handState[i].pos);
        }
      }
    }

    // rubbing: palm distance (use wrist or index fallback)
    const leftPos = handState[0].pos.clone();
    const rightPos = handState[1].pos.clone();
    const palmDist = leftPos.distanceTo(rightPos);
    addRubSample(palmDist, t);
    const rubIntensity = computeRubIntensity();

    // apply rubbing movement forward relative to head
    if (rubIntensity > 0.03) {
      const camF = new THREE.Vector3(); camera.getWorldDirection(camF); camF.y = 0; camF.normalize();
      const nudge = 0.02 * (rubIntensity * 2.5);
      if (renderer.xr.isPresenting) {
        playerBody.position.x += camF.x * nudge;
        playerBody.position.z += camF.z * nudge;
      } else {
        playerBody.velocity.x += camF.x * nudge * 12;
        playerBody.velocity.z += camF.z * nudge * 12;
      }
    }

    // update hand grab kinematics
    updateHandKinematics();

    // maintain orbiting sphere
    maintainOrbit(dt);

    // physics step
    world.step(fixedStep, dt, 4);

    // sync physics -> visuals
    syncPhysicsGraphics();

    // desktop camera orientation
    if (!renderer.xr.isPresenting) camera.quaternion.setFromEuler(new THREE.Euler(pitch || 0, yaw || 0, 0, 'YXZ'));

    renderer.render(scene, camera);
  }
  renderer.setAnimationLoop(animate);

  // resize
  window.addEventListener('resize', ()=> { camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); });

  // expose helpers
  window.spawnBox = spawnBox;
  window.playerBody = playerBody;
  window.handStateDebug = handState;

  console.log('Hand-only VR loaded. Hand-tracking is ON by default; blasters fire from the hands (hand-forward).');

  </script>
</body>
</html>
